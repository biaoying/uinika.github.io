<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bit by bit</title>
  
  <subtitle>Electronics, Embedded &amp; Web</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://uinika.github.io/"/>
  <updated>2020-06-23T16:21:56.432Z</updated>
  <id>https://uinika.github.io/</id>
  
  <author>
    <name>Hank</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android 物联网应用开发实例</title>
    <link href="https://uinika.github.io/Embedded/Android.html"/>
    <id>https://uinika.github.io/Embedded/Android.html</id>
    <published>2020-06-23T15:23:07.155Z</published>
    <updated>2020-06-23T16:21:56.432Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://developer.android.google.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;Android&lt;/strong&gt;&lt;/a&gt; 可以采用 Kotlin、Java、C++ 语言编写应用程序，&lt;a href=&quot;https://developer.android.google.cn/reference&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android SDK&lt;/a&gt; 会将这些代码连同相应的数据和资源文件编译为 Android 软件包，即一个带有&lt;code&gt;.apk&lt;/code&gt;后缀的归档文件，也就是 Android 应用程序的安装文件。本质上 Android 系统是一种多用户的 Linux 系统，每个应用程序都运行在独立的 Linux 用户 &lt;strong&gt;ID&lt;/strong&gt; 和&lt;strong&gt;进程&lt;/strong&gt;之下，从而为每个 Android 应用都提供了独立的&lt;strong&gt;安全沙盒&lt;/strong&gt;，体现了最小权限的设计原则。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Embedded/Android/logo.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;鉴于 Google 官方提供了完善的文档，本文并不过多过深的涉及 Android SDK 开发的具体知识细节，仅会在简单介绍 Android 开发当中的一些基本概念之后，着重分析&lt;strong&gt;经典/低功耗蓝牙&lt;/strong&gt;、&lt;strong&gt;NFC&lt;/strong&gt;、&lt;strong&gt;WIFI&lt;/strong&gt;、&lt;strong&gt;指纹识别&lt;/strong&gt;、&lt;strong&gt;5G&lt;/strong&gt; 等硬件外设的通信协议概念以及相应的实现步骤，并且展示一些比较典型的应用场景与示例代码，从而为读者在进行物联网相关项目的开发时，在移动设备应用控制端提供即有的现成经验。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Embedded" scheme="https://uinika.github.io/categories/Embedded/"/>
    
    
      <category term="Mobile" scheme="https://uinika.github.io/tags/Mobile/"/>
    
  </entry>
  
  <entry>
    <title>Qt 5 桌面应用程序开发指南 - QtWidgets 篇</title>
    <link href="https://uinika.github.io/Linux/Qt-Widgets.html"/>
    <id>https://uinika.github.io/Linux/Qt-Widgets.html</id>
    <published>2020-06-12T15:03:45.355Z</published>
    <updated>2020-06-12T15:03:45.366Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.qt.io/offline-installers&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;Qt 5.14.2&lt;/strong&gt;&lt;/a&gt; 是跨平台应用开发框架 Qt 的最新版本，除了采用基于 &lt;strong&gt;C++11&lt;/strong&gt; 的经典 &lt;a href=&quot;https://doc.qt.io/qt-5/qtwidgets-index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;Qt Widgets&lt;/strong&gt;&lt;/a&gt; 进行桌面应用程序开发以外，还支持通过 &lt;strong&gt;Qt Quick&lt;/strong&gt; 快速开发适用于移动端设备的用户界面，因为 Qt 5 底层图形渲染引擎基于 GPU 硬件加速，所以其能够保持与原生 &lt;strong&gt;C++&lt;/strong&gt; 近乎等同的运行效率。笔者计划通过两篇文章分别对这 2 种技术进行介绍，但是无论如何，在传统跨平台桌面应用开发领域，&lt;strong&gt;Qt Widgets&lt;/strong&gt; 依然是 Qt5 最为基础与核心的内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Linux/Qt-Widgets/logo.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;虽然 Qt 6 发布在即，但是官方声明将会依然保持 API 的兼容与稳定性，因此本文依然基于当前最新的 Qt5 稳定版本撰写。全文将会分别对 &lt;strong&gt;Qt Widgets&lt;/strong&gt; 当中使用较为频繁的&lt;code&gt;窗口部件&lt;/code&gt;、&lt;code&gt;布局管理&lt;/code&gt;、&lt;code&gt;应用主窗口&lt;/code&gt;、&lt;code&gt;事件系统&lt;/code&gt;、&lt;code&gt;对象模型&lt;/code&gt;、&lt;code&gt;风格与样式&lt;/code&gt;、&lt;code&gt;国际化&lt;/code&gt;等部分内容进行深入介绍，同时展示完善的示例代码以及程序运行效果，并结合&lt;a href=&quot;./embedded/Qt-Quick.html&quot;&gt;《QtQuick 篇》&lt;/a&gt;一文讲解混合编程相关的技术。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Qt" scheme="https://uinika.github.io/categories/Qt/"/>
    
    
      <category term="Desktop" scheme="https://uinika.github.io/tags/Desktop/"/>
    
  </entry>
  
  <entry>
    <title>玩转 Raspberry Pi 4B 开源硬件</title>
    <link href="https://uinika.github.io/Embedded/RaspberryPi.html"/>
    <id>https://uinika.github.io/Embedded/RaspberryPi.html</id>
    <published>2020-06-10T13:08:45.069Z</published>
    <updated>2020-06-10T15:22:31.110Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;万众期待的 &lt;strong&gt;Raspberry Pi 4B&lt;/strong&gt; 终于发布，之前由于产品原型的需要，一直计划采购 &lt;strong&gt;3B+&lt;/strong&gt;，后来供应商透露新版 &lt;strong&gt;4B&lt;/strong&gt; 稍晚就会面市，所以稍微等待了一段时间，今天终于拿到了一块 &lt;strong&gt;2G&lt;/strong&gt; 内存的板子。一直以为 &lt;strong&gt;4B&lt;/strong&gt; 只会简单的更新一下 SoC 并增大 &lt;strong&gt;DDR&lt;/strong&gt; 容量，但是实际上还带来了 &lt;strong&gt;Type-C&lt;/strong&gt;、&lt;strong&gt;Bluetooth 5.0&lt;/strong&gt;、&lt;strong&gt;Micro HDMI&lt;/strong&gt;、&lt;strong&gt;USB 3.0&lt;/strong&gt; 乃至 &lt;strong&gt;DDR4&lt;/strong&gt; 等诸多崭新升级。而官方推荐的应用范围，开始从教育渗透至工业领域，逐步发展为一套完整的嵌入式生态链。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Embedded/RaspberryPi/logo.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文基于树莓派基金会官方提供的 &lt;a href=&quot;https://www.raspberrypi.org/documentation/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Raspberry Pi Documentation》&lt;/a&gt;，笔者翻译了其中较为常用的配置章节，便于读者拿到板子以后能够快速上手，并避免使用一些官方不推荐的操作和工具库。此外，本文也会涉及 &lt;code&gt;OpenCV&lt;/code&gt;、&lt;code&gt;dlib&lt;/code&gt; 的编译，以及 &lt;code&gt;Electron&lt;/code&gt; 在树莓派上的部署等话题。文章内容将会伴随笔者的日常使用而长期进行更新，欢迎各位爱好者朋友持续关注与勘误。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Embedded" scheme="https://uinika.github.io/categories/Embedded/"/>
    
    
      <category term="MCU" scheme="https://uinika.github.io/tags/MCU/"/>
    
  </entry>
  
  <entry>
    <title>从 GNU Make 到 CMake 快速入门</title>
    <link href="https://uinika.github.io/Linux/CMake.html"/>
    <id>https://uinika.github.io/Linux/CMake.html</id>
    <published>2020-06-05T14:04:46.579Z</published>
    <updated>2020-06-05T14:04:46.672Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.gnu.org/software/make/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GNU Make&lt;/a&gt;用于控制如何从程序的源代码文件编译并链接为可执行文件，通过&lt;code&gt;make&lt;/code&gt;命令从名称为&lt;code&gt;makefile&lt;/code&gt;的文件中获取构建信息，该文件定义了一系列规则来指定源文件的编译先后顺序、是否需要重新编译、甚至于进行更为复杂的操作。通过&lt;code&gt;makefile&lt;/code&gt;文件可以方便的实现工程的自动化编译，只需要执行&lt;code&gt;make&lt;/code&gt;命令即可完成编译动作，从而极大的提高了开发人员的工作效率。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Linux/CMake/logo.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cmake.org/cmake/help/v3.17/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMake 3.17&lt;/a&gt;是一款源代码构建管理工具，最初作为各种 &lt;strong&gt;Makefile&lt;/strong&gt; 方言的生成器，后来逐步发展为现代化的构建系统，广泛用于 C 和 C++ 工程源代码的构建。官方提供的&lt;a href=&quot;https://cmake.org/cmake/help/latest/guide/tutorial/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《CMake Tutorial》&lt;/a&gt; 为开发人员提供了一个循序渐进的指南，涵盖了 CMake 构建过程中常见问题的解决方案。如果需要构建从第三方发布的源代码包，则可以参考&lt;a href=&quot;https://cmake.org/cmake/help/v3.17/guide/user-interaction/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《User Interaction Guide》&lt;/a&gt;。而&lt;a href=&quot;https://cmake.org/cmake/help/v3.17/guide/using-dependencies/index.html#guide:Using%20Dependencies%20Guide&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Using Dependencies Guide》&lt;/a&gt;则主要针对需要使用第三方库的开发人员。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="https://uinika.github.io/categories/C-C/"/>
    
    
      <category term="Qt" scheme="https://uinika.github.io/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>基于 Linux 的 GCC 与 GDB 应用程序调试</title>
    <link href="https://uinika.github.io/Linux/GCC.html"/>
    <id>https://uinika.github.io/Linux/GCC.html</id>
    <published>2020-06-02T11:58:12.895Z</published>
    <updated>2020-06-02T16:15:56.173Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.gnu.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;GNU&lt;/strong&gt;&lt;/a&gt; 的正确发音为&lt;code&gt;[g&#39;noo]&lt;/code&gt;，名称由英文句子&lt;code&gt;GNU&#39;s Not Unix&lt;/code&gt;递归缩写组成，是一项由&lt;a href=&quot;https://www.fsf.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;自由软件基金会&lt;/a&gt;推动的操作系统计划。GNU 计划最早开始于 1984 年 1 月，目标是完成一个由&lt;strong&gt;Hurd&lt;/strong&gt;内核与一系列应用程序、系统库、开发工具组成的&lt;strong&gt;GNU 操作系统&lt;/strong&gt;。但由于 Hurd 的开发工作迟迟未能完成，因而普遍选择采用 Linux Kernel 作为操作系统的内核，这一套技术组合正是闻名遐迩的 &lt;strong&gt;GNU/Linux&lt;/strong&gt; 操作系统。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Linux/GCC/logo.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;由 &lt;a href=&quot;https://gcc.gnu.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;GCC&lt;/strong&gt;&lt;/a&gt; 与 &lt;a href=&quot;http://www.gnu.org/software/gdb/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;GDB&lt;/strong&gt;&lt;/a&gt; 组成的编译套件正是 GNU 计划下诞生的优秀开源项目，也是 GNU/Linux 技术体系不可或缺的构成要素。虽然当前 &lt;a href=&quot;http://clang.llvm.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;Clang&lt;/strong&gt;&lt;/a&gt; 与 &lt;a href=&quot;https://www.llvm.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;LLVM&lt;/strong&gt;&lt;/a&gt; 编译套件的发展风头正劲，但是由于嵌入式 Linux 设备通常只提供基于 GCC 的交叉编译工具链，加之两者在使用上差异不大，而 GDB 又同时提供了两者编译后程序的完整 Debug 支持，因而笔者依然选择 &lt;strong&gt;GCC&lt;/strong&gt; 与 &lt;strong&gt;GDB&lt;/strong&gt; 组合来作为本文的撰写的目标。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Note" scheme="https://uinika.github.io/categories/Note/"/>
    
    
      <category term="Linux" scheme="https://uinika.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 常用命令行速查手册</title>
    <link href="https://uinika.github.io/Linux/Command.html"/>
    <id>https://uinika.github.io/Linux/Command.html</id>
    <published>2020-06-02T11:58:12.879Z</published>
    <updated>2020-06-06T07:32:18.099Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Linux Mint 最早于 2006 年开始发行，是一款基于 &lt;strong&gt;Debian&lt;/strong&gt; 与 &lt;strong&gt;Ubuntu&lt;/strong&gt; 的 Linux 发行版，提供了更为友好稳定的桌面环境，在进行快捷键、开源字体等方面的设置，并安装了诸多的工具软件之后，笔者将其作为日常工作环境已有近 5 年的历史，伴随近几年开源团队不断的改进与升级，其兼容性与用户体验渐入佳境。从程序编写到 PCB 电路绘制，日常工作已经愈加依赖这款 Linux 操作系统。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Linux/Command/logo.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;基于 2019 年圣诞节发布的 &lt;strong&gt;Linux mint 19.3&lt;/strong&gt; 发行版，采用的 Shell 命令解释器版本为 &lt;strong&gt;Bash Shell 5.0.3&lt;/strong&gt;，文章总结了笔者日常所经常使用到的 Linux 命令，在简明扼要的介绍相关命令与参数之后，还展示了各条命令的实际执行结果，便于读者更加直观的了解其功能与用途。限于文章篇幅以及命令行的使用频率，有关 Bash Shell 脚本编程部分的内容，将会新开一篇文章再行介绍。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://uinika.github.io/categories/Linux/"/>
    
    
      <category term="Embedded" scheme="https://uinika.github.io/tags/Embedded/"/>
    
  </entry>
  
  <entry>
    <title>面向对象的 C++ 11 程序设计语言</title>
    <link href="https://uinika.github.io/Linux/C++.html"/>
    <id>https://uinika.github.io/Linux/C++.html</id>
    <published>2020-06-01T12:34:24.855Z</published>
    <updated>2020-06-01T16:08:24.553Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;2011 年，C++ 标准委员会发布了 ISO C++ 标准的一个重要修订版 &lt;strong&gt;C++ 11&lt;/strong&gt;；该修订版是 C++ 语言演进过程当中的重要一步，也是当前获得编译器（&lt;a href=&quot;http://gcc.gnu.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GCC&lt;/a&gt;、&lt;a href=&quot;https://llvm.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LLVM&lt;/a&gt;、&lt;a href=&quot;https://www.qt.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Qt5&lt;/a&gt;、&lt;a href=&quot;https://docs.microsoft.com/zh-cn/cpp/cpp/c-cpp-language-and-standard-libraries?view=vs-2017&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Visual C++&lt;/a&gt;支持较多，兼容性最为优秀的一个版本。增添了类型说明符&lt;code&gt;auto&lt;/code&gt;和&lt;code&gt;decltype&lt;/code&gt;、&lt;code&gt;Lambda 表达式&lt;/code&gt;、&lt;code&gt;智能指针 unique_ptr shared_ptr weak_ptr&lt;/code&gt;、&lt;code&gt;空指针 nullptr&lt;/code&gt;等诸多新特性，语言风格更加灵活统一的同时，极大提升了程序的编写效率。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Linux/C++/logo.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文基于&lt;a href=&quot;https://www.pearson.com/store/p/c-primer/P100001360317/9780321714114?tab=for-teachers&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《C++ Primer》&lt;/a&gt;一书最新的第 5 版撰写而成，该书作为 C++ 语言学习的经典读物，同样与时俱进增添了 C++ 11 的诸多新特性。因此，本文也选择了支持 C++ 11 标准的 &lt;strong&gt;Qt5&lt;/strong&gt; 作为开发编译环境。由于 C++ 面向过程的语法与 C 语言类似，而笔者之前已经在&lt;a href=&quot;/linux/c-reference.html&quot;&gt;《Linux C 标准程序设计》&lt;/a&gt;一文对相关内容进行了详尽的表述，因而本文将会着重笔墨水介绍 C++ 面向对象以及标准库方面的内容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="https://uinika.github.io/categories/C-C/"/>
    
    
      <category term="Qt" scheme="https://uinika.github.io/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>Windows 工作环境 Config 札记</title>
    <link href="https://uinika.github.io/Zen/Config-Windows.html"/>
    <id>https://uinika.github.io/Zen/Config-Windows.html</id>
    <published>2020-05-25T12:23:38.339Z</published>
    <updated>2020-05-28T16:13:15.003Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;开发人员长期以来对于 Microsoft Windows 操作系统总抱以嗤之以鼻的态度，笔者亲身经历了&lt;code&gt;Windows XP&lt;/code&gt;、&lt;code&gt;Windows 7&lt;/code&gt;到&lt;code&gt;Windows 10&lt;/code&gt;的版本演变过程，抛开众所周知的偏见，事实上是能够感觉到系统稳定性、用户体验方面的大幅改善的，叠加近年来 &lt;a href=&quot;http://cmder.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;Cmder&lt;/strong&gt;&lt;/a&gt;、&lt;a href=&quot;https://neovim.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;Neovim&lt;/strong&gt;&lt;/a&gt; 等辅助开发工具的出现与逐渐成熟，作为软件开发环境，其使用体验已经完全可以与 Linux 媲美，并在图形界面的稳定性以及交互的友好性方面胜于后者。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Zen/Config-Windows/logo.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;但是对于广大硬件电子工程师而言，&lt;strong&gt;Altium Designer&lt;/strong&gt;、&lt;strong&gt;Pads&lt;/strong&gt;、&lt;strong&gt;Allegro&lt;/strong&gt; 等商业 EDA 工具仅提供支持 Windows 操作系统的版本，而高频高速 PCB 电路设计基本离不开 Windows 操作系统环境，因而 Windows 和 Linux 在笔者日常工作里都各自拥有着其不可替代性。本文主要用于记录一些笔者使用 Windows 10 操作系统的配置和习惯，便于切换到新的工作环境时快速的展开，因而文章也会持续的保持更新。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Zen" scheme="https://uinika.github.io/categories/Zen/"/>
    
    
      <category term="Windows Config" scheme="https://uinika.github.io/tags/Windows-Config/"/>
    
  </entry>
  
  <entry>
    <title>Webpack 4 核心剖析</title>
    <link href="https://uinika.github.io/Web/Webpack.html"/>
    <id>https://uinika.github.io/Web/Webpack.html</id>
    <published>2020-05-21T13:39:03.892Z</published>
    <updated>2020-05-21T15:28:49.754Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://webpack.js.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Webpack&lt;/a&gt;&lt;/strong&gt; 是现代 Web 应用程序的静态模块打包工具，它会递归的构建应用程序各个模块的依赖关系图，然后将所有模块打包成一个或多个&lt;code&gt;bundle&lt;/code&gt;。目前 Webpack 已经更新至 &lt;strong&gt;4.29.6&lt;/strong&gt; 版本，增加了诸多打包和执行性能相关的支持，是目前应用最广泛、社区最活跃的 Web 前端代码打包方案。而更新版本的 Webpack 5 已经进入 Beta 发布阶段，未来将会带来更多构建性能的提升，本文依然以更为稳定的 Webpack 4 为讲解对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Web/Webpack/logo.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;Webpack 提出了&lt;strong&gt;入口&lt;/strong&gt;&lt;code&gt;entry&lt;/code&gt;、&lt;strong&gt;输出&lt;/strong&gt;&lt;code&gt;output&lt;/code&gt;、&lt;strong&gt;加载器&lt;/strong&gt;&lt;code&gt;loader&lt;/code&gt;、&lt;strong&gt;插件&lt;/strong&gt;&lt;code&gt;plugin&lt;/code&gt;这四个核心概念，本文将会在简单介绍 Webpack 相关基础概念之后，对其原生实现的&lt;code&gt;import&lt;/code&gt;模块导入机制进行分析，以清晰的展现 Wepback 在底层所进行的工作；最后逐步备注笔者在开发、生产环境下使用到的各类插件和加载器，并分享在&lt;a href=&quot;https://github.com/uinika/aves&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;aves&lt;/a&gt;和&lt;a href=&quot;https://github.com/uinika/rhino&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;rhino&lt;/a&gt;两个开源脚手架项目当中（&lt;em&gt;分别基于 Vue2 和 React16&lt;/em&gt;）所使用到的最佳配置实践。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web" scheme="https://uinika.github.io/categories/Web/"/>
    
    
      <category term="JavaScript" scheme="https://uinika.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Linux 工作环境 Config 札记</title>
    <link href="https://uinika.github.io/Zen/Config-Linux.html"/>
    <id>https://uinika.github.io/Zen/Config-Linux.html</id>
    <published>2020-05-21T13:39:03.892Z</published>
    <updated>2020-05-21T13:39:03.892Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;使用 Linux 作为日常&lt;strong&gt;开发&lt;/strong&gt;和&lt;strong&gt;工作&lt;/strong&gt;环境近 5 年时间，尝试过&lt;code&gt;Debian&lt;/code&gt;、&lt;code&gt;Fedora&lt;/code&gt;、&lt;code&gt;Ubuntu&lt;/code&gt;、&lt;code&gt;Mint&lt;/code&gt;等桌面发行版。虽然 Linux 作为服务器运行稳定可靠，但是在桌面 GUI 体验一直有待改进，显卡驱动兼容性与 CPU 占用率过高等问题一直悬而未决。而日常工作当中经常需要使用到的&lt;code&gt;Altium Designer&lt;/code&gt;、&lt;code&gt;Keil uVision&lt;/code&gt;等商业软件仅提供 Windows 10 版本，因此笔者时常需要在两款操作系统之间来回进行切换。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Zen/Config-Linux/logo.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;Linux Mint 提供了嵌入式开发当中必不可少的交叉编译环境，也能够直接安装 &lt;code&gt;KiCAD&lt;/code&gt;、&lt;code&gt;STM32CubeIDE&lt;/code&gt;、&lt;code&gt;VSCode&lt;/code&gt;、&lt;code&gt;Sublime&lt;/code&gt; 等生产力工具；Windows 10 则提供了 &lt;code&gt;Altium Designer&lt;/code&gt;、开发板串口驱动等大量无法跨平台使用的商业软件支持。本文主要用于备注两款操作系统当中一些常用的开发与工作环境配置，便于后续在全新工作环境中展开部署，以方便的移植个性化的使用习惯至新设备。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Zen" scheme="https://uinika.github.io/categories/Zen/"/>
    
    
      <category term="Linux Config" scheme="https://uinika.github.io/tags/Linux-Config/"/>
    
  </entry>
  
  <entry>
    <title>SCSS 3.5.5 简明上手指南</title>
    <link href="https://uinika.github.io/Web/Scss.html"/>
    <id>https://uinika.github.io/Web/Scss.html</id>
    <published>2020-05-21T13:39:03.876Z</published>
    <updated>2020-05-21T15:33:26.888Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://sass-lang.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Sass&lt;/a&gt;&lt;/strong&gt; 是成熟、稳定、强大的&lt;strong&gt;CSS 预处理器&lt;/strong&gt;，截止到目前为止已经发展有 10 年，前当最新 release 版本为&lt;code&gt;3.5.5&lt;/code&gt;。而&lt;strong&gt;SCSS&lt;/strong&gt;是&lt;strong&gt;Sass3&lt;/strong&gt;版本当中引入的新语法特性，完全兼容 CSS3 的同时继承了&lt;strong&gt;Sass&lt;/strong&gt;强大的动态功能。本文翻译自&lt;a href=&quot;http://sass-lang.com/guide&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Sass Guide》&lt;/a&gt;和&lt;a href=&quot;http://sass-lang.com/documentation/file.SASS_REFERENCE.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Sass Syntactically Awesome StyleSheets》&lt;/a&gt;两篇官方文档，讲解了现代化前端开发当中经常使用的 SCSS 语法特性，便于开发小组的同学快速上手。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Web/Scss/logo.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;基于 Gulp 完成前端自动化的年代，出于快速上手以及 npm 安装方便的考虑，开发团队一直沿用&lt;a href=&quot;http://lesscss.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Less&lt;/a&gt;和&lt;a href=&quot;https://github.com/stevelacy/gulp-less&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gulp-less&lt;/a&gt;作为 CSS 预处理工具，但是 Sass 提供了更加丰富的动态语法特征，因此逐步淘汰基于 Gulp 的&lt;a href=&quot;https://github.com/uinika/beaver&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;beaver&lt;/a&gt;前端项目脚手架以后，新项目全部基于 Webpack 的&lt;a href=&quot;https://github.com/sass/node-sass&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;node-sass&lt;/a&gt;和&lt;a href=&quot;https://github.com/webpack-contrib/sass-loader&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;sass-loader&lt;/a&gt;作为预处理工具。Sass 和 Less 的详细比较可以参考&lt;a href=&quot;https://css-tricks.com/sass-vs-less/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;sass-vs-less&lt;/a&gt;和&lt;a href=&quot;http://cued.xunlei.com/log044&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Sass 与 Less 比拼&lt;/a&gt;两篇文章，里面对两者的优劣做了非常详实的比较。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web" scheme="https://uinika.github.io/categories/Web/"/>
    
    
      <category term="CSS" scheme="https://uinika.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Vue 2 技术栈归纳与精粹</title>
    <link href="https://uinika.github.io/Web/Vue.html"/>
    <id>https://uinika.github.io/Web/Vue.html</id>
    <published>2020-05-21T13:39:03.876Z</published>
    <updated>2020-05-21T13:39:03.876Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Vue 是一款&lt;strong&gt;高度封装的&lt;/strong&gt;、&lt;strong&gt;开箱即用的&lt;/strong&gt;、&lt;strong&gt;一栈式的前端框架&lt;/strong&gt;，既可以结合 webpack 进行编译式前端开发，也适用基于 gulp、grunt 等自动化工具直接挂载至&lt;code&gt;全局window&lt;/code&gt;使用。本文成文于 Vue2.4.x 版本发布之初，笔者生产环境当前使用的最新版本为 &lt;code&gt;2.5.2&lt;/code&gt;。在经历多个前端重度交互项目的开发实践之后，笔者结合官方文档对 Vue 技术栈进行了全面的梳理、归纳和注解，因此本文可以作为 Vue2 官方&lt;a href=&quot;https://vuejs.org/v2/guide/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Get Started》&lt;/a&gt; 的补充性读物。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Web/Vue/logo.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Vue2.2.x&lt;/code&gt;发布之后，其框架体系及技术栈日趋完善，相较于&lt;code&gt;React+Reflux/Redux/MobX&lt;/code&gt;技术栈，Vue 更加贴近 W3C 技术规范（&lt;em&gt;例如实现仍处于 W3C 草案阶段的&lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt;、&lt;code&gt;is&lt;/code&gt;等新特性，提供了良好易用的模板书写环境&lt;/em&gt;），并且开源生态更加完整并易于配置，将 React 大量手动编码处理的位置，整合成为最佳实践并抽象为简单的语法糖（比如 Vuex 中提供的&lt;code&gt;store&lt;/code&gt;的模块化特性），使得开发人员得以将注意力聚焦于业务逻辑本身。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web" scheme="https://uinika.github.io/categories/Web/"/>
    
    
      <category term="JavaScript" scheme="https://uinika.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>NodeJS 快速上手指南</title>
    <link href="https://uinika.github.io/Web/Nodejs.html"/>
    <id>https://uinika.github.io/Web/Nodejs.html</id>
    <published>2020-05-21T13:39:03.860Z</published>
    <updated>2020-05-21T13:39:03.860Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;NodeJS&lt;/strong&gt; 开源项目于 2009 年由 &lt;strong&gt;Google Brain&lt;/strong&gt; 团队的软件工程师 Ryan Dahl 发起创建，后被美国云计算企业 &lt;a href=&quot;https://www.joyent.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Joyent&lt;/a&gt; 招入麾下，2015 年后正式被 &lt;a href=&quot;https://foundation.nodejs.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NodeJS 基金会&lt;/a&gt; 接管，三星公司于 2016 年完成了对 Joyent 的收购。经过将近 10 年的发展，NodeJS 已经成为现代化前端开发过程中不可或缺的基础架构，即可以作为页面渲染的分布式服务器，也可以作为前端自动化的宿主环境。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Web/Nodejs/logo.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文基于笔者在 2015 年所写的一篇读书笔记整理，彼时 &lt;a href=&quot;https://nodejs.org/en/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;node.js&lt;/a&gt; 的版本号还停留在&lt;code&gt;v0.12.x&lt;/code&gt;，社区也还未完成与 &lt;a href=&quot;https://iojs.org/en/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;io.js&lt;/a&gt; 的最终合并，文中出现的部分 API 时至今日已经被废弃或者迁移。但是这些 API 层面的变化都可以对照 &lt;a href=&quot;https://nodejs.org/dist/latest-v8.x/docs/api/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《官方文档》&lt;/a&gt;找到相应说明以及替代 API，总体上并不会影响通过本文快速了解 NodeJS 的全套技术栈特性。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web" scheme="https://uinika.github.io/categories/Web/"/>
    
    
      <category term="Server" scheme="https://uinika.github.io/tags/Server/"/>
    
  </entry>
  
  <entry>
    <title>言简意赅 の Python3</title>
    <link href="https://uinika.github.io/Web/Python.html"/>
    <id>https://uinika.github.io/Web/Python.html</id>
    <published>2020-05-21T13:39:03.860Z</published>
    <updated>2020-05-21T13:39:03.860Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Python 诞生于 20 世纪 90 年代初，由荷兰人 Guido van Rossum 开发完成，是一款非常简洁易读的解释型脚本语言；擅长于科学计算与图形处理，传统的计算机视觉库&lt;a href=&quot;https://opencv.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OpenCV&lt;/a&gt;、三维可视化库&lt;a href=&quot;https://www.vtk.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;VTK&lt;/a&gt;、医学图像处理库&lt;a href=&quot;https://itk.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ITK&lt;/a&gt;都提供了 Python 调用接口，Python 也原生提供了&lt;a href=&quot;http://www.numpy.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NumPy&lt;/a&gt;、&lt;a href=&quot;https://www.scipy.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SciPy&lt;/a&gt;、&lt;a href=&quot;https://matplotlib.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;matplotlib&lt;/a&gt;等强大的科学计算扩展库。Web 开发方面，Python 也提供有&lt;a href=&quot;https://www.Djangoproject.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Django&lt;/a&gt;、&lt;a href=&quot;http://www.tornadoweb.org/en/stable/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Tornado&lt;/a&gt;两款常用的 Web 开发框架。总而言之，得益于强大的开源社区支持，Python 已经成为一门功能丰富的胶水语言。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Web/Python/logo.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文的示例代码基于目前最新的&lt;a href=&quot;https://www.python.org/downloads/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Python 3.6.6&lt;/a&gt;版本，在简单介绍相关语法以及&lt;a href=&quot;https://pypi.org/project/pip/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pip&lt;/a&gt;、&lt;a href=&quot;https://virtualenv.pypa.io/en/stable/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;virtualenv&lt;/a&gt;等扩展库的使用之后，将会最终完成一个基于官方 XML 解析库&lt;code&gt;ElementTree&lt;/code&gt;的 SVG 图片合并小程序。本文涉及的代码和 Markdown 都已经上传至笔者的&lt;a href=&quot;https://github.com/uinika/python-quick-guide&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github&lt;/a&gt;，需要的朋友可以直接进行克隆，如果发现缪误或有任何建议请向我提交&lt;a href=&quot;https://github.com/uinika/python-quick-guide/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;issue&lt;/a&gt;。此外，笔者正在撰写[&lt;a href=&quot;https://uinika.github.io/web/server/django.html&quot;&gt;《使用 Django2 快速开发 Web 项目》&lt;/a&gt;一文，供需要使用 Python 进行 Web 开发的朋友进一步阅读。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web" scheme="https://uinika.github.io/categories/Web/"/>
    
    
      <category term="Server" scheme="https://uinika.github.io/tags/Server/"/>
    
  </entry>
  
  <entry>
    <title>React 16.6.x 全新全译</title>
    <link href="https://uinika.github.io/Web/React.html"/>
    <id>https://uinika.github.io/Web/React.html</id>
    <published>2020-05-21T13:39:03.860Z</published>
    <updated>2020-05-21T13:39:03.860Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;全文翻译自&lt;a href=&quot;https://reactjs.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;React 16.6.0 英文文档&lt;/a&gt;，适当精简了生产环境不经常使用的内容，并对部分较为复杂的概念进行了更加翔实的解读，以及与 Vue2 进行了一些特性方面的比较。本文首先会介绍&lt;strong&gt;React 16&lt;/strong&gt;带来的一系列变化与新特性，然后解读 React 官方文档&lt;a href=&quot;https://reactjs.org/docs/hello-world.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Docs&lt;/a&gt;当中&lt;strong&gt;Quick Start&lt;/strong&gt;和&lt;strong&gt;Advanced Guides&lt;/strong&gt;的内容，最后基于项目上的使用实践，开源了一个较为完整的&lt;strong&gt;&lt;a href=&quot;https://github.com/uinika/rhino.git&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;脚手架项目Rhino&lt;/a&gt;&lt;/strong&gt;，适合已经具备&lt;strong&gt;组件式&lt;/strong&gt;前端框架开发经验的同学快速上手。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Web/React/logo.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;2017 年 9 月 &lt;strong&gt;Facebook&lt;/strong&gt; 释出&lt;code&gt;React v16.0.x&lt;/code&gt;，宣布使用对商业使用更加友好的 &lt;a href=&quot;https://mit-license.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;MIT license&lt;/strong&gt;&lt;/a&gt; 开源许可，并带来了全新的&lt;code&gt;render()&lt;/code&gt;函数返回类型、更加健壮的错误处理机制、全新的&lt;code&gt;Fragment&lt;/code&gt;和&lt;code&gt;Portal&lt;/code&gt; 特性，并完全重写了类库的核心架构，带来更为优异服务器端渲染性能的同时，有效缩小了类库代码本身的体积，更重要的意义在于杜绝了 &lt;a href=&quot;https://github.com/developit/preact&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;Preact&lt;/strong&gt;&lt;/a&gt; 等衍生框架对 React 社区所造成的分裂。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web" scheme="https://uinika.github.io/categories/Web/"/>
    
    
      <category term="JavaScript" scheme="https://uinika.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>概览 HTML 5 语义化标签</title>
    <link href="https://uinika.github.io/Web/Html.html"/>
    <id>https://uinika.github.io/Web/Html.html</id>
    <published>2020-05-21T13:39:03.845Z</published>
    <updated>2020-05-21T13:39:03.845Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;本文翻译自 Mozilla 社区的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《HTML Reference》&lt;/a&gt;，包含了 &lt;strong&gt;HTML5&lt;/strong&gt; 新增的元素标签及属性，并对使用场景、语义化用法进行了简要说明，便于快速定位日常开发所需要的 HTML 标签，书写更加优雅的语义化 DOM 结构。本文所涉及的 HTML 元素全部通过 &lt;a href=&quot;https://caniuse.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;Can I use&lt;/strong&gt;&lt;/a&gt; 进行了兼容性校对，在标注各个 HTML 元素兼容性状态的同时，提供了 &lt;strong&gt;W3C&lt;/strong&gt; 和 &lt;strong&gt;Mozilla&lt;/strong&gt; 推荐的标准 Demo 用例，便于快速开发格式良好的 Web 页面，体现更加&lt;strong&gt;语义化&lt;/strong&gt;的文档结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Web/Html/logo.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;HTML 超文本标记语言（&lt;em&gt;Hypertext Markup Language&lt;/em&gt;）是构建 Web 页面的基石，用于结构化的组织页面元素与内容，可以嵌入图像、视频等多媒体，也可以用于创建交互式表单，并在一定程度上描述文档的外观和语义。&lt;strong&gt;HTML 语义化&lt;/strong&gt;（&lt;em&gt;Semantic HTML&lt;/em&gt;）则是指合理的使用 HTML 元素编写 Web 页面内容，&lt;strong&gt;强调 Web 页面编码信息的含义凌驾于其表现样式之上&lt;/strong&gt;，有利于 Web 浏览器执行规范化解析，改善网页文档的可访问性，方便搜索引擎爬虫索引。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web" scheme="https://uinika.github.io/categories/Web/"/>
    
    
      <category term="HTML" scheme="https://uinika.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 协议深入解析</title>
    <link href="https://uinika.github.io/Web/Http.html"/>
    <id>https://uinika.github.io/Web/Http.html</id>
    <published>2020-05-21T13:39:03.845Z</published>
    <updated>2020-05-21T13:39:03.845Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.w3.org/Protocols/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HTTP&lt;/a&gt; 是基于 &lt;strong&gt;TCP/IP&lt;/strong&gt; 协议而建立 Web 基础协议，从 1989 年早期的简单 &lt;strong&gt;HTTP/0.9&lt;/strong&gt; 单行协议开始，至 1996 年逐步扩展了状态码、协议头等特性发展到 &lt;strong&gt;HTTP/1.0&lt;/strong&gt;，然后在 1997 年的 &lt;strong&gt;HTTP/1.1&lt;/strong&gt; 增加了 TCP 连接复用、流水线支持、响应分块、缓存控制、内容协商等特性。2015 年 &lt;strong&gt;HTTP/2&lt;/strong&gt; 协议正式标准化之后，传统 HTTP 的文本协议被二进制协议替代，让并行的请求在同 1 个 TCP 连接中处理，并移除了&lt;code&gt;header&lt;/code&gt;中的重复数据，大幅提升通信效率。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Web/Http/logo.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;在各类现代化 Web 服务器与开发框架群雄并起的年代，无论是 Python 的&lt;a href=&quot;https://www.djangoproject.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Django&lt;/a&gt;、&lt;a href=&quot;http://www.tornadoweb.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Tornado&lt;/a&gt;，还是 Java 的&lt;a href=&quot;http://www.oracle.com/technetwork/java/index-jsp-135475.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Servlet&lt;/a&gt;或者是 Go 上的&lt;a href=&quot;https://beego.me/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BeeGo&lt;/a&gt;，其本质上都是基于&lt;a href=&quot;https://www.w3.org/Protocols/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HTTP 协议&lt;/a&gt;的封装。因此了解 HTTP 相关协议规范能够提升 Web 开发的透明度，能够从协议角度理解 Web 报文的通信过程，而非仅仅从各类 Web 开发框架及其 API 封装的角度。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web" scheme="https://uinika.github.io/categories/Web/"/>
    
    
      <category term="Convention" scheme="https://uinika.github.io/tags/Convention/"/>
    
  </entry>
  
  <entry>
    <title>jQuery 那些容易被忽略的问题</title>
    <link href="https://uinika.github.io/Web/JQuery.html"/>
    <id>https://uinika.github.io/Web/JQuery.html</id>
    <published>2020-05-21T13:39:03.845Z</published>
    <updated>2020-05-21T13:39:03.845Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;伴随&lt;code&gt;Vue&lt;/code&gt;、&lt;code&gt;Angular&lt;/code&gt;、&lt;code&gt;React&lt;/code&gt;等编译式前端框架的崛起，前端开发人员逐渐从繁琐的 DOM 操作当中解脱出来。但是在项目实践过程当中，依然存有诸多问题需要通过直接操作 DOM 来解决，虽然现代化浏览器已经支持&lt;code&gt;selectAll()&lt;/code&gt;等 HTML5 新特性，但是针对一些强调页面兼容性的场景，为了屏蔽各款浏览器解析引擎所遵循规范的差异，依然需要借助于&lt;code&gt;jQuery&lt;/code&gt;来完成 DOM 文档操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Web/JQuery/logo.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;因此&lt;code&gt;jQuery&lt;/code&gt;这款诞生于 2006 年的 JavaScript 库，依然在&lt;strong&gt;现代化前端开发&lt;/strong&gt;当中扮演着较为重要角色。本文结合笔者 Web 前端开发工作当中积累的实践经验，较为系统的总结了&lt;code&gt;jQuery&lt;/code&gt;实践过程当中一些比较容易被开发人员所忽略的问题。例如 jQuery 对象与 DOM 对象的相互转换、jQuery 选择器性能、异步对象&lt;code&gt;$.Deferred()&lt;/code&gt;以及 JavaScript 性能优化相关的话题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web" scheme="https://uinika.github.io/categories/Web/"/>
    
    
      <category term="JavaScript" scheme="https://uinika.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 6 简明语法书</title>
    <link href="https://uinika.github.io/Web/Javascript.html"/>
    <id>https://uinika.github.io/Web/Javascript.html</id>
    <published>2020-05-21T13:39:03.845Z</published>
    <updated>2020-05-21T13:39:03.845Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript 遵循了 ECMAScript 语言规范，2012 年之后的现代浏览器都完整支持 &lt;strong&gt;ECMAScript 5.1&lt;/strong&gt; 标准。2015 年 6 月 17 日，ECMA 国际组织发布了 &lt;strong&gt;ECMAScript 6&lt;/strong&gt; 标准，官方称为 &lt;strong&gt;ECMAScript 2015&lt;/strong&gt;（俗称为 &lt;strong&gt;ES6&lt;/strong&gt;），从此 ECMAScript 每年发布一次新标准，&lt;strong&gt;本文覆盖了当前最新 ECMAScript2017 草案中的新特性&lt;/strong&gt;。示例代码和术语定义参考了《JavaScrip 高级程序设计》，但是该书成文于 ES6 发布之前，因此从&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Mozilla JavaScript Reference》&lt;/a&gt;摘取了部分内容作为补充。出于查阅与核对的方便，本文目录结构与 Mozilla 官方英文文档保持一致。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Web/Javascript/logo.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;JavaScript 标准化工作由&lt;strong&gt;ECMA&lt;/strong&gt;（&lt;em&gt;European Computer Manufacturers Association&lt;/em&gt;）国际组织负责，JavaScript 的语言标准被称为&lt;strong&gt;ECMAScript&lt;/strong&gt;，企业遵循该标准开发各自的 JavaScript 实现，例如 Firefox 的&lt;code&gt;SpiderMonkey&lt;/code&gt;或者 Chrome 中的&lt;code&gt;V8&lt;/code&gt;解析引擎（&lt;em&gt;ECMAScript 的规范文档主要针对解析引擎的开发人员，而非 JavaScript 脚本的编写人员&lt;/em&gt;）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web" scheme="https://uinika.github.io/categories/Web/"/>
    
    
      <category term="JavaScript" scheme="https://uinika.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>使用 Electron 打造跨平台桌面应用</title>
    <link href="https://uinika.github.io/Web/Electron.html"/>
    <id>https://uinika.github.io/Web/Electron.html</id>
    <published>2020-05-21T13:39:03.829Z</published>
    <updated>2020-05-21T13:39:03.829Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;早期桌面应用的开发主要借助原生 C/C++ API 进行，由于需要反复经历编译过程，且无法分离界面 UI 与业务代码，开发调试极为不便。后期出现的 QT 和 WPF 在一定程度上解决了界面代码分离和跨平台的问题，却依然无法避免较长时间的编译过程。近几年伴随互联网行业的迅猛发展，尤其是 NodeJS、Chromium 这类基于 W3C 标准开源应用的不断涌现，原生代码与 Web 浏览器开发逐步走向融合，Electron 正是在这种背景下诞生的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Web/Electron/logo.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;Electron 是由 Github 开发，通过将&lt;a href=&quot;www.chromium.org&quot;&gt;Chromium&lt;/a&gt;和&lt;a href=&quot;https://nodejs.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NodeJS&lt;/a&gt;整合为一个运行时环境，实现使用 HTML、CSS、JavaScript 构建跨平台的桌面应用程序的目的。Electron 源于 2013 年 Github 社区提供的开源编辑器 Atom，后于 2014 年在社区开源，并在 2016 年的 5 月和 8 月，通过了 &lt;a href=&quot;https://www.apple.com/mac/app-store/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Mac App Store&lt;/a&gt; 和 &lt;a href=&quot;https://apps.microsoft.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Windows Store&lt;/a&gt; 的上架许可，VSCode、Skype 等著名开源或商业应用程序，都是基于 Electron 打造。为了方便编写测试用例，笔者在 Github 搭建了一个简单的 Electron 种子项目&lt;a href=&quot;https://github.com/uinika/octopus&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Octopus&lt;/a&gt;，读者可以基于此来运行本文涉及的示例代码。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web" scheme="https://uinika.github.io/categories/Web/"/>
    
    
      <category term="Server" scheme="https://uinika.github.io/tags/Server/"/>
    
  </entry>
  
</feed>
