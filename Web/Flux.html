<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#8C634F">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/favicon.png" color="#8C634F">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Monda:300,300italic,400,400italic,700,700italic|Source+Code+Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"uinika.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#A38272","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Flux是由 Facebook 在 2014 年 7 月提出的一种 React 应用体系架构，主要用于解决多层级组件之间数据传递以及状态管理的问题。并由此派生出了Reflux、Redux、MobX等一系列单向数据流框架。为 Web 前端页面实现组件化拆分之后，组件间的通信与协同机制提供了一套较为完善的方法学。其核心理念在于将所有应用状态放置在Store内进行统一管理，视图层组件只能通过触发Acti">
<meta property="og:type" content="article">
<meta property="og:title" content="Flux 数据流两三事儿">
<meta property="og:url" content="https://uinika.github.io/Web/Flux.html">
<meta property="og:site_name" content="Bit by bit">
<meta property="og:description" content="Flux是由 Facebook 在 2014 年 7 月提出的一种 React 应用体系架构，主要用于解决多层级组件之间数据传递以及状态管理的问题。并由此派生出了Reflux、Redux、MobX等一系列单向数据流框架。为 Web 前端页面实现组件化拆分之后，组件间的通信与协同机制提供了一套较为完善的方法学。其核心理念在于将所有应用状态放置在Store内进行统一管理，视图层组件只能通过触发Acti">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://uinika.github.io/Web/Flux/logo.png">
<meta property="og:image" content="https://uinika.github.io/Web/Flux/flux-diagram.png">
<meta property="og:image" content="https://uinika.github.io/Web/Flux/reflux-diagram.png">
<meta property="og:image" content="https://uinika.github.io/Web/Flux/redux-react.png">
<meta property="og:image" content="https://uinika.github.io/Web/Flux/mobx-overview.jpg">
<meta property="og:image" content="https://uinika.github.io/Web/Flux/mobx-flow.png">
<meta property="og:image" content="https://uinika.github.io/Web/Flux/mobx-with-react.gif">
<meta property="og:image" content="https://uinika.github.io/Web/Flux/mobx-with-computed.gif">
<meta property="article:published_time" content="2020-10-13T18:33:09.031Z">
<meta property="article:modified_time" content="2020-10-13T18:33:09.031Z">
<meta property="article:author" content="Hank">
<meta property="article:tag" content="JavaScript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://uinika.github.io/Web/Flux/logo.png">

<link rel="canonical" href="https://uinika.github.io/Web/Flux.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Flux 数据流两三事儿 | Bit by bit</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Bit by bit" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Bit by bit</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Electronics, Embedded & Web</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-th-large"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">56</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">26</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-briefcase"></i>分类<span class="badge">12</span></a>

  </li>
        <li class="menu-item menu-item-it圈">

    <a href="/industry/" rel="section"><i class="fa fa-fw fa-microchip"></i>IT圈</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/uinika" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://uinika.github.io/Web/Flux.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hank">
      <meta itemprop="description" content="My world of IT, learn it & play it.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bit by bit">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Flux 数据流两三事儿
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-14 02:33:09" itemprop="dateCreated datePublished" datetime="2020-10-14T02:33:09+08:00">2020-10-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web/" itemprop="url" rel="index"><span itemprop="name">Web</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>21k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>19 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><a href="https://facebook.github.io/flux/" target="_blank" rel="noopener">Flux</a>是由 <strong>Facebook</strong> 在 2014 年 7 月提出的一种 React 应用体系架构，主要用于解决多层级组件之间数据传递以及状态管理的问题。并由此派生出了<a href="https://github.com/reflux/refluxjs" target="_blank" rel="noopener">Reflux</a>、<a href="http://redux.js.org/" target="_blank" rel="noopener">Redux</a>、<a href="https://mobx.js.org" target="_blank" rel="noopener">MobX</a>等一系列单向数据流框架。为 Web 前端页面实现组件化拆分之后，组件间的通信与协同机制提供了一套较为完善的方法学。其核心理念在于将所有应用状态放置在<code>Store</code>内进行统一管理，视图层组件只能通过触发<code>Action</code>修改<code>Store</code>中的应用状态。</p>
<p><img src="/Web/Flux/logo.png"></p>
<p>本文首先系统的概括 Facebook 官方的<strong>Flux</strong>以及<strong>单向数据流</strong>思想，然后遵循近几年<strong>Flux 衍生框架</strong>的发展历程，逐步进行概括性的分析与比较，并顺带介绍了 Vue 技术栈当中的<strong>类 Flux 框架</strong> <a href="https://vuex.vuejs.org/en/" target="_blank" rel="noopener">VueX</a>，最后，由于通常将<code>Action</code>视为 <strong>Flux</strong> 工作流的核心与起点，本文还对<a href="https://github.com/redux-utilities/flux-standard-action" target="_blank" rel="noopener">《Flux Standard Action》</a>自述文档进行了翻译，以期更为全面的展现 Flux 生态的演进过程。</p>
<a id="more"></a>
<h2 id="flux">Flux</h2>
<p>Flux 是 Facebook 官方构建 Web 前端应用体系架构，通过<strong>数据的单向流动</strong>有效补足了 React 组件间通信的短板，Flux 架构思想主要由如下 4 个部份组成：</p>
<ol type="1">
<li><strong>Action</strong>：视图层发出的动作信息，可以来自于用户交互，也可能来自于服务器响应。</li>
<li><strong>Dispatcher</strong>：派发器，用来接收 Actions 并执行相应回调函数。</li>
<li><strong>Store</strong>：用来存放应用的状态，一旦发生变化就会通知视图进行重绘。</li>
<li><strong>View</strong>：React 组件视图。</li>
</ol>
<h3 id="单向数据流">单向数据流</h3>
<p>所谓的<strong>单向数据流（<em>unidirectional data flow</em>）</strong>是指用户访问<strong>View</strong>，<strong>View</strong>发出用户交互的<strong>Action</strong>，<strong>Dispatcher</strong>收到<strong>Action</strong>之后，要求<strong>Store</strong>进行相应更新。<strong>Store</strong>更新后会发出一个<code>change</code>事件，<strong>View</strong>收到<code>change</code>事件后更新页面的过程。这样数据总是清晰的单向进行流动，便于维护并且可以预测。</p>
<p><img src="/Web/Flux/flux-diagram.png"></p>
<!-- ![](Flux/unidirectional-data-flow.png) -->
<h3 id="dispatcher">Dispatcher</h3>
<p><code>dispatcher</code>集中管理 Flux 应用程序的全部数据流，本质上是<code>store</code>上注册的回调函数，主要用于分发<code>action</code>到<code>store</code>，并维护多个<code>store</code>之间的依赖关系（<em>官方实现是通过 Dispatcher 类上的 waitFor()方法</em>）。</p>
<p>当<strong>Action Creator</strong>发起一个新的<code>action</code>到<code>dispatcher</code>，应用中的所有<code>store</code>都将通过注册的回调函数接收到<code>action</code>。伴随应用程序的增长，<code>dispatcher</code>会变得极为重要，因为需要它通过指定顺序的回调函数去管理<code>store</code>之间的依赖。<code>Store</code>会声明式的等待其它<code>store</code>完成更新后再相应的更新自己。</p>
<blockquote>
<p><code>dispatcher</code>是官方 Flux 当中<code>action</code>和<code>store</code>的粘合剂。</p>
</blockquote>
<h3 id="store">Store</h3>
<p><code>store</code>包含应用的<code>state</code>和逻辑，作用类似于传统 MVC 中的<code>Model</code>，但它管理着多个对象的状态。</p>
<p><code>store</code>将自己注册到<code>dispatcher</code>，并提供一个接收<code>action</code>作为参数的回调函数。在<code>store</code>注册的回调函数中，将会通过基于<code>action</code>类型的<code>switch</code>判断语句进行解释操作，并为<code>store</code>的内部方法提供适当的钩子函数。这允许<code>action</code>通过<code>dispatcher</code>对<code>store</code>当中的<code>state</code>进行更新。在这些<code>store</code>被更新之后，会广播一个事件声明其状态已经被改变，从而让<code>view</code>可以设置新的<code>state</code>并更新自己。</p>
<h3 id="view">View</h3>
<p>在 React 嵌套视图层级结构的顶部，有一种特殊的视图可以监听其所依赖的<code>store</code>广播的事件，这种视图称为<strong>控制器视图</strong>（<em>controller-view</em>）。因为它提供了从<code>store</code>获取数据的粘合代码，并传递这些数据给子组件。</p>
<p>当控制器视图接收到来自<code>store</code>的事件时，会首先通过<code>store</code>公有的<code>getter()</code>方法获取新数据，然后调用组件自身的<code>setState()</code>或<code>forceUpdate()</code>方法，使其本身以及子组件的<code>render()</code>方法都得到调用。</p>
<p>通常会将<code>store</code>上的全部<code>state</code>传递给单个对象的视图链，允许不同的子组件按需进行使用。除了将控制器的行为保持在视图层次结构的顶部，从而让子视图尽可能地保持功能上的纯洁外；将存储在单个对象中的整个状态传递下来，也可以减少我们需要管理的<code>props</code>的数量。</p>
<blockquote>
<p>有些时候，可能需要向更深的视图层次结构添加额外的控制器视图以保持组件的简单，这可能有助于更好的封装与指定数据域相关的那部分视图层次结构。然而值得注意的是，这些更深层次的控制器视图会引入新的数据流入口，从而破坏单向数据流并引发各种奇怪的错误，而且难以 debug。因此，在决定添加更深层次控制器视图之前，需要仔细的进行权衡。</p>
</blockquote>
<h3 id="action">Action</h3>
<p><code>dispatcher</code>会暴露一个接收<code>action</code>的方法，去触发<code>store</code>的调度，并包含数据的<code>payload</code>（<em>[ˈpeɪləʊd] n.有效载荷</em>）。<code>action</code>的建立可能会被封装到用于发送<code>action</code>至<code>dispatcher</code>的语义化的帮助函数（<em>Action Creator</em>）当中。例如：我们需要改变<code>to-do-list</code>应用中的 1 个<code>to-do-item</code>，就需要在<code>TodoActions</code>模块中建立签名为<code>updateText(todoId, newText)</code>的函数，该函数能被视图组件里的事件处理器调用以响应用户交互。这个 Action Creator 方法还需要添加一个<code>type</code>属性到<code>action</code>，这样当<code>action</code>在<code>store</code>中被解释的时候可以被正确的响应。前面例子中，<code>type</code>属性的值可以是<code>TODO_UPDATE_TEXT</code>。</p>
<blockquote>
<p><code>action</code>也可能来自其它地方，比如服务器。在组件数据初始化的过程中，或者服务器返回错误代码，以及服务器存在需要提供给应用程序的更新的时候。</p>
</blockquote>
<h2 id="reflux">Reflux</h2>
<p><strong><a href="https://github.com/reflux/refluxjs" target="_blank" rel="noopener">Reflux</a></strong>是一种 Flux 单向数据流体系架构的具体实现，主要由<code>action</code>和<code>store</code>组成，其中<code>action</code>会在重新回到视图组件之前初始化新的数据并传递到<code>store</code>，而视图组件只能通过发送<code>action</code>去改变<code>store</code>中的数据。</p>
<p><img src="/Web/Flux/reflux-diagram.png"></p>
<p>相当长一段时间里，开源社区普遍认为官方 Flux 又臭又长过于学院派，因此 Reflux 实现大幅精简 Flux 的各类晦涩概念（<em>最大的变化是移除了<code>dispatcher</code></em>），只保留如下 3 个主要概念：</p>
<ol type="1">
<li>建立 Action。</li>
<li>建立 Store。</li>
<li>连接 React 组件和 Store。</li>
</ol>
<blockquote>
<p><strong>存在炫技的倾向，将简单概念复杂化解读是开发人员编写技术文档一个通病</strong>。</p>
</blockquote>
<h3 id="建立-action">建立 Action</h3>
<p>调用<code>Reflux.createAction()</code>并传入可选的配置对象就能新建一个 Action，这个配置对象的可选项如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  actionName: <span class="string">'myActionName'</span>,  <span class="comment">// action的名称</span></span><br><span class="line">  children: [<span class="string">'childAction'</span>],   <span class="comment">// 异步操作中由子操作action名称所组成的数组</span></span><br><span class="line">  asyncResult: <span class="literal">true</span>,           <span class="comment">// 设置为true会快捷添加'completed'和'failed'两个子action</span></span><br><span class="line">  sync: <span class="literal">false</span>,                 <span class="comment">// 设置action同步或者异步的发生（默认是同步的，除非存在子action）</span></span><br><span class="line">  preEmit: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;,    <span class="comment">// 定义preEmit方法</span></span><br><span class="line">  shouldEmit: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;  <span class="comment">// 定义shouldEmit方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，建立 Action 时也可以缺省传入配置对象，如同下面代码中这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> statusUpdate = Reflux.createAction();</span><br><span class="line"></span><br><span class="line">statusUpdate(data); <span class="comment">// 调用Action</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Reflux 中 Action 是一个能够被其它函数所调用的普通函数式对象。</strong></p>
</blockquote>
<p>还可以调用<code>Reflux.createActions([...])</code>一次性建立多个<code>action</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 现在Actions对象拥有了多个action</span></span><br><span class="line"><span class="keyword">var</span> Actions = Reflux.createActions([</span><br><span class="line">    <span class="string">"statusAdded"</span></span><br><span class="line">    <span class="string">"statusEdited"</span>,</span><br><span class="line">    <span class="string">"statusRemoved"</span>,</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过Actions.xxx的方式调用指定的Action</span></span><br><span class="line">Actions.statusRemoved();</span><br></pre></td></tr></table></figure>
<p>Reflux 中的 Action 还可以使用子 Action 异步加载文件，进行<code>preEmit</code>和<code>shouldEmit</code>检查（<em>Action 发出事件之前被调用</em>），并拥有多个易于使用的快捷方式。</p>
<h3 id="异步-action-处理">异步 Action 处理</h3>
<p>正如上面所描述的，一个 Action 可以简单的通过<code>myAction()</code>方式进行调用，如果<code>sync</code>属性被设置为<code>true</code>则 Action 是同步的，将会立刻通过<code>myAction.trigger()</code>被执行；如是<code>sync</code>设置为<code>false</code>则是异步 Action，将会在 JavaScript 事件循环的下一个 tick 内通过<code>myAction.triggerAsync()</code>执行，并且 Action 配置对象的<code>children</code>属性可能会被设置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Actions = Reflux.createActions([</span><br><span class="line">  &#123;</span><br><span class="line">    actionName: <span class="string">"myName"</span>,</span><br><span class="line">    sync: <span class="literal">false</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Action 默认情况下是同步的</strong>，除非在配置对象内进行了其它配置，或者 Action 本身还包含了其它子 Action。</p>
</blockquote>
<p>当需要通过子 Action 去执行诸如文件加载一类的的异步 Action，那么该 Action 需要监听自身然后去执行这个异步操作，当操作完成的时候调用其子 Action，下面代码简单体现了这一过程：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> action = Reflux.createAction(&#123; <span class="attr">children</span>: [<span class="string">"delayComplete"</span>] &#125;);</span><br><span class="line"></span><br><span class="line">action.listen(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="keyword">this</span>.delayComplete, <span class="number">50000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="建立-store">建立 Store</h3>
<p>Flux 建立<code>store</code>的方式非常类似于 React 组件，通过继承<code>Reflux.Store</code>对象就可以得到一个<code>store</code>，该<code>store</code>和组件一样都拥有一个可以通过<code>setState()</code>方法进行更新的<code>state</code>属性。</p>
<p>可以在<code>store</code>对象的<code>constructor()</code>方法内设置<code>state</code>的初值，并使用<code>listenTo()</code>设置指定<code>action</code>的监听器。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StatusStore</span> <span class="keyword">extends</span> <span class="title">Reflux</span>.<span class="title">Store</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">flag</span>: <span class="string">"OFF"</span> &#125;; <span class="comment">// 设置store的默认state</span></span><br><span class="line">    <span class="keyword">this</span>.listenTo(statusUpdate, <span class="keyword">this</span>.onStatusUpdate); <span class="comment">// 监听statusUpdate action并使用onStatusUpdate函数进行响应</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onStatusUpdate(status) &#123;</span><br><span class="line">    <span class="keyword">let</span> newFlag = status ? <span class="string">"ON"</span> : <span class="string">"OFF"</span>;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">flag</span>: newFlag &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面例子中名为<code>statusUpdate</code>的 Action 被调用后，<code>store</code>上的<code>onStatusUpdate()</code>回调函数会传入 Action 上携带的参数。例如：Action 以<code>statusUpdate(true)</code>方式调用，那么<code>onStatusUpdate()</code>函数中的<code>status</code>参数值就为<code>true</code>。</p>
<p>Store 可以通过<code>this.listenables()</code>方便的整合多个 Action，当一个 Action 对象或者一个 Action 对象的数组应用到该函数上，Reflux 可以<strong>根据命名约定自动添加监听器</strong>。只需要在<code>action</code>名称之后重命名这些函数的名称，例如自动在<code>actionName</code>前加上<code>on</code>，使之变成 Store 中<code>action</code>事件回调函数的名称<code>onActionName()</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Actions = Reflux.createActions([<span class="string">"firstAction"</span>, <span class="string">"secondAction"</span>]);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StatusStore</span> <span class="keyword">extends</span> <span class="title">Reflux</span>.<span class="title">Store</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.listenables = Actions;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onFirstAction() &#123;</span><br><span class="line">    <span class="comment">// 被Actions.firstAction()触发</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onSecondAction() &#123;</span><br><span class="line">    <span class="comment">// 被Actions.secondAction()触发</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Flux 中的 Store 非常强大，甚至可以贡献出一个全局状态（<em>正如 Redux 所倡导的那样</em>），可以只对部分状态进行读取或设置，或是对全部状态进行时间旅行、调试。</p>
</blockquote>
<h3 id="连接-react-组件和-store">连接 React 组件和 Store</h3>
<p>建立 Action 和 Store 之后，最后一步就是将 Store 与 React 组件连接起来。</p>
<p>Reflux 中通过<code>Reflux.Component</code>新建 React 组件，而不是继续使用<code>React.Component</code>。由于<code>Reflux.Component</code>底层实现上继承了<code>React.Component</code>，因此两者功能和特性完全相同，唯一区别在于通过继承<code>Reflux.Component</code>实现的组件能够设置<code>store</code>并且从中获取<code>state</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Reflux</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;&#125;; <span class="comment">// our store will add its own state to the component's</span></span><br><span class="line">    <span class="keyword">this</span>.store = StatusStore; <span class="comment">// 将上一步建立的StatusStore传递给当前组件</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="keyword">this</span>.state.flag; <span class="comment">// flag属性已经从StatusStore中混入(mixin)当前组件的state</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>开关状态：&#123;flag&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当组件挂载之后，将会建立一个新的<code>StatusStore</code>的单例对象（<em>如果没有</em>），或是使用一个已经建立的单例对象（<em>由使用这个 Store 的其它组件建立</em>）。但是，这里还可以注意如下 2 点：</p>
<ol type="1">
<li>可以向<code>this.stores</code>传递一个<code>store</code>数组来方便的设置多个 Store。</li>
<li>设置一个<code>this.storeKeys</code>数组来约束<code>store</code>上的指定部分会被混入(<em>mixin</em>)到组件的<code>state</code>。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Reflux</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">type</span>: <span class="string">"admin"</span> &#125;; <span class="comment">// 注意我们仍然在使用普通的state</span></span><br><span class="line">    <span class="keyword">this</span>.stores = [StatusStore, AnotherStore];</span><br><span class="line">    <span class="keyword">this</span>.storeKeys = [<span class="string">"flag"</span>, <span class="string">"info"</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">var</span> flag = <span class="keyword">this</span>.state.flag;</span><br><span class="line">    <span class="keyword">var</span> info = <span class="keyword">this</span>.state.info;</span><br><span class="line">    <span class="keyword">var</span> type = <span class="keyword">this</span>.state.type;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        Flag &#123;flag&#125;, <span class="attr">Info</span>: &#123;info&#125;, <span class="attr">Type</span>: &#123;type&#125;。</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中，将会混入<code>StatusStore</code>和<code>AnotherStore</code>中的<code>state</code>，但是又由于<code>this.storeKeys</code>只允许混入<code>flag</code>和<code>info</code>，因此其它属性（<em>例如 type 属性</em>）不会被混入，而<code>type</code>在组件的构造方法内已经进行了赋值处理，否则<code>render()</code>函数渲染时会因为获取不到<code>type</code>属性的值而报错。</p>
<p>Reflux 以简单直接的方式整合<code>store</code>到组件上，可以将所有<code>store</code>聚合到一起，然后让组件有选择性的按需进行过滤。</p>
<blockquote>
<p>虽然截止笔者成文为止，Reflux 的最后一次提交记录还停留在一年前的 2017 年 2 月，但是个人认为针对于中小型项目，Reflux 相对后续发展起来的 Redux 更加简单明了一些。</p>
</blockquote>
<h2 id="redux">Redux</h2>
<p><strong><a href>Redux</a></strong>可以认为是 Flux 思想的一种实现，两者在存在许多相同点的同时，也有诸多方面的异同。</p>
<p>Flux 和 Redux 都规定，将模型的更新逻辑放置在特定的逻辑层（Flux 里是<code>store</code>，Redux 是<code>reducer</code>）。Flux 和 Redux 都不允许直接修改<code>store</code>，而是使用称为<code>action</code>的普通 JavaScript 对象来对更改进行描述。两者不同之处在于，Redux 并没有<code>dispatcher</code>概念，通过使用纯函数去代替 Flux 中的事件处理器。</p>
<p><img src="/Web/Flux/redux-react.png"></p>
<blockquote>
<p>Redux 实质上在官方 Flux 基础上增加了诸多细节，因此各类概念又臭又长的问题依然未有任何实质性改观（<em>如上图</em>），其提出的概念要比其实现的代码略多 ⊙﹏⊙‖。</p>
</blockquote>
<h3 id="基本原则">基本原则</h3>
<ol type="1">
<li>单一数据源，整个应用的<code>state</code>被储存在一棵对象树，并且这棵对象树只存在于唯一的<code>store</code>当中。</li>
<li>State 是只读的，修改<code>state</code>的唯一方法是触发<code>action</code>，<code>action</code>本质是一个用于描述发生事件的普通 JavaScript 对象。</li>
<li>使用纯函数<code>reducer</code>来执行修改，从而描述<code>action</code>如何修改<code>state</code>树。</li>
</ol>
<blockquote>
<p><code>Reducer</code>只是一些纯函数，它接收先前的<code>state</code>和<code>action</code>，并返回新的<code>state</code>。刚开始你可以只有一个<code>reducer</code>，随着应用变大，你可以把它拆成多个小的<code>reducers</code>，分别独立地操作<code>state</code>树的不同部分。</p>
</blockquote>
<h3 id="action-1">Action</h3>
<p>Action 是把数据从应用（<em>视图交互或服务器响应数据</em>）传递到<code>store</code>的有效载荷，是<code>store</code>数据的唯一来源，通常需要通过<code>store.dispatch()</code>将<code>action</code>传递至<code>store</code>。</p>
<p>Action 本质上是一个 JavaScript 普通对象，通常约定<code>action</code>内必须使用一个字符串类型的<code>type</code>字段来表示将要执行的动作。<code>type</code>可以被简单的定义为字符串常量，应用规模较大的时候建议使用单独模块存放<code>action</code>。除<code>type</code>字段外，<code>action</code>对象的结构完全由开发人员自行决定。当然也可以参照 Redux 社区制定的<a href="/web/flux.html#FSA">《Flux 标准 Action 规范》</a>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: <span class="string">'ADD_TODO'</span>,</span><br><span class="line">  payload: <span class="keyword">new</span> <span class="built_in">Error</span>(),</span><br><span class="line">  error: <span class="literal">true</span>,</span><br><span class="line">  meta:&#123;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Action 创建函数</strong>（<em>即 Flux 中的 Action Creator</em>）是生成<code>action</code>的方法，Redux 中的<strong>Action 创建函数</strong>只是简单返回一个<code>action</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTodo</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: <span class="string">"ADD_TODO"</span>,</span><br><span class="line">    payload: <span class="keyword">new</span> <span class="built_in">Error</span>(),</span><br><span class="line">    error: <span class="literal">true</span>,</span><br><span class="line">    meta: &#123;&#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面介绍的官方 Flux 实现当中，调用<strong>Action 创建函数</strong>将会触发<code>dispatch</code>，参考下面的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTodoWithFlux</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> action = &#123;</span><br><span class="line">    type: ADD_TODO,</span><br><span class="line">    text,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// Flux官方实现将dispatch()方法放置在action创建函数当中</span></span><br><span class="line">  dispatch(action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Redux 当中，只需要将<strong>Action 创建函数</strong>的结果传递给<code>dispatch()</code>即可发起一次<code>dispatch</code>过程。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将Redux创建函数直接传递给dispatch()</span></span><br><span class="line">dispatch(addTodo(text));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>虽然 Redux 的<code>store</code>里能直接调用<code>store.dispatch()</code>，但是多数情况下会使用<a href="https://github.com/reactjs/react-redux" target="_blank" rel="noopener">react-redux</a>提供的<code>connect()</code>来进行调用。<code>bindActionCreators()</code>可以自动将多个 Action 创建函数绑定至<code>dispatch()</code>。</p>
</blockquote>
<h3 id="reducer">Reducer</h3>
<p>Reducer 用来描述如何根据<code>action</code>对<code>store</code>进行修改，是<code>action</code>与<code>store</code>的黏合剂（<em>官方 Flux 中充当这一作用的是 dispatcher</em>）。</p>
<p>Reducer 本质是一个纯函数，接收旧的<code>state</code>和<code>action</code>，返回新的<code>state</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(previousState, action) =&gt; newState;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>一定要保持 Reducer 的纯净</strong>，只要传入参数相同，Reducer 返回的下一个<code>state</code>就一定相同（<em>没有特殊情况、没有副作用，没有 API 请求、没有变量修改，单纯执行计算</em>）。</p>
</blockquote>
<p>下面的代码声明了<code>todos</code>和<code>todosFilter</code>两个<code>reducer</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">"redux"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// todos reducer</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">todos</span>(<span class="params">state = [], action</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断action的类型，分别返回不同的状态</span></span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> ADD_TODO:</span><br><span class="line">      <span class="keyword">return</span> [</span><br><span class="line">        ...state,</span><br><span class="line">        <span class="comment">// 合并到状态中的内容</span></span><br><span class="line">        &#123; <span class="attr">text</span>: action.text, <span class="attr">completed</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">      ];</span><br><span class="line">    <span class="keyword">case</span> TOGGLE_TODO:</span><br><span class="line">      <span class="keyword">return</span> state.map(<span class="function">(<span class="params">todo, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index === action.index) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, todo, &#123;</span><br><span class="line">            completed: !todo.completed,</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> todo;</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// visibilityFilter reducer</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">todosFilter</span>(<span class="params">state = SHOW_ALL, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> SET_VISIBILITY_FILTER:</span><br><span class="line">      <span class="keyword">return</span> action.filter;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个<code>reducer</code>只负责管理全局<code>state</code>中的一部分，其<code>state</code>参数只对应它管理的那部分<code>state</code>数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 合并Reducer，是上面代码的语法糖</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">todoApp</span>(<span class="params">state = &#123;&#125;, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    todos: todos(state.todos, action),</span><br><span class="line">    todosFilter: todosFilter(state.todosFilter, action),</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>伴随应用规模的膨胀，可能需要将<code>reducer</code>拆分到不同的文件, 以保持其独立性并专门用于处理不同数据域。因此 Redux 提供了<code>combineReducers()</code>工具方法来完成上面<code>todoApp</code>的工作，从而实现简化代码的目的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 合并Reducer，是上面代码的语法糖</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> todoApp = combineReducers(&#123;</span><br><span class="line">  todos,</span><br><span class="line">  todosFilter,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>combineReducers()</code>用来生成一个调用一系列自定义<code>reducer</code>的函数，每个<code>reducer</code>根据<code>key</code>筛选出<code>state</code>中的具体一部分数据并处理，最后这个生成函数会将所有<code>reducer</code>的返回结果合并为一个大对象。</p>
<h3 id="store-1">Store</h3>
<p><strong>Action</strong>用来描述发生的行为，<strong>Reducer</strong>用来根据<code>action</code>更新<code>state</code>。<code>Store</code>则是两者联系的关键，Redux 应用只有一个单一的<code>store</code>，当需要拆分数据处理逻辑时，应该组合使用<code>reducer</code>，而非创建多个<code>store</code>。</p>
<ul>
<li>保存应用的<code>state</code>；</li>
<li>提供<code>getState()</code>方法获取<code>state</code>；</li>
<li>提供<code>dispatch(action)</code>方法更新<code>state</code>；</li>
<li>通过<code>subscribe(listener)</code>注册监听器;</li>
<li>使用<code>subscribe(listener)</code>返回的函数注销监听器。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">"redux"</span>;</span><br><span class="line"><span class="keyword">import</span> todoApp <span class="keyword">from</span> <span class="string">"./reducers"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> store = createStore(todoApp);</span><br></pre></td></tr></table></figure>
<h3 id="middleware-与-thunk">Middleware 与 Thunk</h3>
<p>Redux 的<strong>Middleware</strong>可以提供<code>action</code>发起之后，到达<code>reducer</code>之前的扩展点，因此可以利用<strong>Middleware</strong>进行日志记录、创建崩溃报告、调用异步接口或路由等。</p>
<p>通过使用指定的<strong>Middleware</strong>（<em><a href="https://github.com/gaearon/redux-thunk" target="_blank" rel="noopener">redux-thunk</a>、<a href="https://github.com/redux-utilities/redux-promise" target="_blank" rel="noopener">redux-promise</a>、<a href="https://github.com/acdlite/redux-rx" target="_blank" rel="noopener">redux-rx</a></em>），<strong>Action 创建函数</strong>（<em>Action Creator</em>）除了返回<code>action</code>对象外还可以返回<strong>函数</strong>、<strong>Promise</strong>、<strong>Observable</strong>，这种情况下 Action 创建函数就被称为<strong>thunk</strong>（[θʌŋk] 形实转换程序）。</p>
<p><strong>Action 创建函数</strong>返回的函数会被<code>redux-thunk</code>中间件执行，该函数不需要保持纯净，可以执行异步请求或者<code>dispatch</code>一个或多个<code>action</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fetch <span class="keyword">from</span> <span class="string">"isomorphic-fetch"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> REQUEST_INFO = <span class="string">"REQUEST_INFO"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestInfo</span>(<span class="params">info</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: REQUEST_INFO,</span><br><span class="line">    info,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> RECEIVE_INFO = <span class="string">"RECEIVE_INFO"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receiveInfo</span>(<span class="params">info, json</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: RECEIVE_INFO,</span><br><span class="line">    info,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thunk函数的使用与普通Action创建函数相同：store.dispatch(fetchInfo('Hello Hank!'))</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchInfo</span>(<span class="params">info</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将dispatch方法通过参数传递给返回的函数，使返回函数体内也具备dispatch action的能力</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">dispatch</span>) </span>&#123;</span><br><span class="line">    dispatch(requestInfo(info)); <span class="comment">// 首次dispatch更新state去通知API请求发起</span></span><br><span class="line">    <span class="comment">// thunk函数可以有返回值，该返回值会作为dispatch方法的返回值传递，下面的代码返回一个promise</span></span><br><span class="line">    <span class="keyword">return</span> fetch(<span class="string">`http://www.uinika.cn/test/<span class="subst">$&#123;info&#125;</span>.json`</span>)</span><br><span class="line">      .then(<span class="function">(<span class="params">response</span>) =&gt;</span> response.json())</span><br><span class="line">      .then(</span><br><span class="line">        (json) =&gt; dispatch(receivePosts(info, json)) <span class="comment">// 使用请求结果更新应用的state</span></span><br><span class="line">      );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>远程 API 请求通常需要发起 3 种异步 Action，分别用于通知<code>reducer</code>请求<em>开始、成功、失败</em>，可以考虑向<code>action</code>添加一个<code>status</code>字段来区分 3 种状态。</p>
</blockquote>
<p>Redux 提供的<code>createStore()</code>创建的<code>store</code>只支持同步数据流，需要通过 Redux 的<code>applyMiddleware()</code>方法应用<code>redux-thunk</code>去支持异步数据流。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">"redux"</span>;</span><br><span class="line"><span class="keyword">import</span> thunkMiddleware <span class="keyword">from</span> <span class="string">"redux-thunk"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; fetchInfo &#125; <span class="keyword">from</span> <span class="string">"./actions"</span>;</span><br><span class="line"><span class="keyword">import</span> rootReducer <span class="keyword">from</span> <span class="string">"./reducers"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">  rootReducer,</span><br><span class="line">  applyMiddleware(</span><br><span class="line">    thunkMiddleware,</span><br><span class="line">  )</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">store.dispatch(</span><br><span class="line">  fetchInfo(<span class="string">"Hello Hank!"</span>).then(</span><br><span class="line">    () =&gt; <span class="built_in">console</span>.info(store.getState()</span><br><span class="line">  )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="连接-redux-与-react">连接 Redux 与 React</h3>
<p>React 编写的 App 组件需要连接至 Redux，使其能够<code>dispatch actions</code>以及从<code>Redux store</code>读取<code>state</code>。</p>
<p>首先，需要通过<a href="https://github.com/reactjs/react-redux" target="_blank" rel="noopener">react-redux</a>提供的<code>&lt;Provider&gt;</code>包裹应用的根组件，使得<code>store</code>可以被根组件下的所有子级组件访问（<em>通过 React 的 context 特性实现</em>）。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">"redux"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">"react-redux"</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">"./components/App"</span>;</span><br><span class="line"><span class="keyword">import</span> todoApp <span class="keyword">from</span> <span class="string">"./reducers"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> store = createStore(todoApp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> root = <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>);</span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Provider&gt;,</span></span><br><span class="line"><span class="regexp">  root</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure>
<p>然后，通过<a href="https://github.com/reactjs/react-redux" target="_blank" rel="noopener">react-redux</a>提供的<code>connect()</code>方法将包装好的组件连接至 Redux。尽量只做一个顶层的组件，或者<code>route</code>处理。</p>
<p>从<code>connect()</code>包装的组件可以得到一个<code>dispatch()</code>作为组件的<code>props</code>，以及获取全局<code>state</code>中所需的任意内容。<code>connect()</code>方法的唯一参数是<code>selector</code>，该方法从<code>store</code>接收到全局的<code>state</code>，然后返回组件中需要的 <code>props</code>。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  addTodo,</span><br><span class="line">  completeTodo,</span><br><span class="line">  setVisibilityFilter,</span><br><span class="line">  VisibilityFilters,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">"../actions"</span>;</span><br><span class="line"><span class="keyword">import</span> React, &#123; Component, PropTypes &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> TodoList <span class="keyword">from</span> <span class="string">"../components/TodoList"</span>;</span><br><span class="line"><span class="keyword">import</span> AddTodo <span class="keyword">from</span> <span class="string">"../components/AddTodo"</span>;</span><br><span class="line"><span class="keyword">import</span> Footer <span class="keyword">from</span> <span class="string">"../components/Footer"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">"react-redux"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; dispatch, visibleTodos, visibilityFilter &#125; = <span class="keyword">this</span>.props; <span class="comment">// 通过调用connect()进行注入</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;AddTodo onAddClick=&#123;(text) =&gt; dispatch(addTodo(text))&#125; /&gt;</span><br><span class="line">        &lt;TodoList</span><br><span class="line">          todos=&#123;<span class="keyword">this</span>.props.visibleTodos&#125;</span><br><span class="line">          onTodoClick=&#123;(index) =&gt; dispatch(completeTodo(index))&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;Footer</span><br><span class="line">          filter=&#123;visibilityFilter&#125;</span><br><span class="line">          onFilterChange=&#123;(nextFilter) =&gt;</span><br><span class="line">            dispatch(setVisibilityFilter(nextFilter))</span><br><span class="line">          &#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function selectTodos(todos, filter) &#123;</span></span><br><span class="line"><span class="regexp">  switch (filter) &#123;</span></span><br><span class="line"><span class="regexp">    case VisibilityFilters.SHOW_ALL:</span></span><br><span class="line"><span class="regexp">      return todos;</span></span><br><span class="line"><span class="regexp">    case VisibilityFilters.SHOW_ACTIVE:</span></span><br><span class="line"><span class="regexp">      return todos.filter((todo) =&gt; !todo.completed);</span></span><br><span class="line"><span class="regexp">    case VisibilityFilters.SHOW_COMPLETED:</span></span><br><span class="line"><span class="regexp">      return todos.filter((todo) =&gt; todo.completed);</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 选择需要哪部分state注入至组件的props</span></span><br><span class="line"><span class="regexp">function select(state) &#123;</span></span><br><span class="line"><span class="regexp">  return &#123;</span></span><br><span class="line"><span class="regexp">    visibleTodos: selectTodos(state.todos, state.visibilityFilter),</span></span><br><span class="line"><span class="regexp">    visibilityFilter: state.visibilityFilter,</span></span><br><span class="line"><span class="regexp">  &#125;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 注入dispatch和state到App组件</span></span><br><span class="line"><span class="regexp">export default connect(select)(App);</span></span><br></pre></td></tr></table></figure>
<h2 id="mobx">Mobx</h2>
<p>Mobx 是最新的 React 状态管理解决方案，其设计思想大量借鉴自 Vuex，能够方便的对状态进行自动更新，并且提供了十分好用的装饰器语法糖。</p>
<p><img src="/Web/Flux/mobx-overview.jpg"></p>
<p>首先，通过下面语句，安装 Mobx 及其绑定库、装饰器语法支持。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  npm install mobx --save</span><br><span class="line">➜  npm install mobx-react --save</span><br><span class="line">➜  npm install --save-dev babel-preset-mobx</span><br></pre></td></tr></table></figure>
<p>然后，修改<code>.babelrc</code>打开装饰器语法支持：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [<span class="string">"mobx"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用 VSCode 编辑器，启用 Mobx 装饰器语法支持后，需要添加如下设置项，开启语法支持避免编辑器出现错误提示。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"javascript.implicitProjectConfig.experimentalDecorators"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基本概念">基本概念</h3>
<ul>
<li><strong>State</strong>：<em>状态</em>，驱动 Mobx 应用程序的数据。</li>
<li><strong>Action</strong>：<em>动作</em>，一段可以改变状态 State 的代码，例如：用户事件、后端推送等。严格模式下，MobX 强制只能使用 Action 修改 State。</li>
<li><strong>Derivation</strong>：<em>[deri'veiʃən] 推导，衍生</em>，源自状态并且不会再有进一步的相互作用，MobX 将<strong>衍生</strong>分为如下两种类型：
<ol type="1">
<li><strong>Reaction</strong>：<em>反应</em>，指 State 状态发生改变时自动产生的变化，在 MobX 当中较为常用。</li>
<li><strong>Computed values</strong>：<em>计算值</em>，通过纯函数监听可观察的 State，并根据这些 State 的变化重新来计算新值。</li>
</ol></li>
</ul>
<p><img src="/Web/Flux/mobx-flow.png"></p>
<h3 id="简单例子">简单例子</h3>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; observable, autorun &#125; <span class="keyword">from</span> <span class="string">"mobx"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">  @observable testNumber = <span class="number">100</span>;</span><br><span class="line">  @observable testString = <span class="string">"test string!"</span>;</span><br><span class="line">  @observable testObject = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line">  @observable testArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> storeInstance = <span class="keyword">new</span> Store();</span><br><span class="line"></span><br><span class="line"><span class="comment">// autorun()函数首先会触发一次，然后每次observe数据发生变化时会再次触发</span></span><br><span class="line">autorun(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"--------"</span>);</span><br><span class="line">  <span class="built_in">console</span>.info(storeInstance.testNumber);</span><br><span class="line">  <span class="built_in">console</span>.info(storeInstance.testString);</span><br><span class="line">  <span class="built_in">console</span>.dir(storeInstance.testObject);</span><br><span class="line">  <span class="built_in">console</span>.dir(storeInstance.testArray);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">storeInstance.testNumber = <span class="number">200</span>;</span><br><span class="line">storeInstance.testString = <span class="string">"another test string!"</span>;</span><br><span class="line">storeInstance.testObject.b = <span class="number">0</span>;</span><br><span class="line">storeInstance.testArray[<span class="number">0</span>] = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 输出结果：</span></span><br><span class="line"><span class="comment">  --------</span></span><br><span class="line"><span class="comment">  100</span></span><br><span class="line"><span class="comment">  test string!</span></span><br><span class="line"><span class="comment">  Object</span></span><br><span class="line"><span class="comment">  ObservableArray</span></span><br><span class="line"><span class="comment">  --------</span></span><br><span class="line"><span class="comment">  200</span></span><br><span class="line"><span class="comment">  test string!</span></span><br><span class="line"><span class="comment">  Object</span></span><br><span class="line"><span class="comment">  ObservableArray</span></span><br><span class="line"><span class="comment">  --------</span></span><br><span class="line"><span class="comment">  200</span></span><br><span class="line"><span class="comment">  another test string!</span></span><br><span class="line"><span class="comment">  Object</span></span><br><span class="line"><span class="comment">  ObservableArray</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="结合-react-使用">结合 React 使用</h3>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; observable &#125; <span class="keyword">from</span> <span class="string">"mobx"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; observer &#125; <span class="keyword">from</span> <span class="string">"mobx-react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立store并使time属性处于observable状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">  @observable time = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> storeInstance = <span class="keyword">new</span> Store();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每间隔1秒time属性就加一</span></span><br><span class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  storeInstance.time++;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用@observer声明Timer组件，当storeInstance当中的time属性发生变化时，该组件将会被实时渲染</span></span><br><span class="line">@observer</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Timer</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>传入时间: &#123;this.props.store.time&#125; <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将storeInstance作为Timer组件的props传入，并将实时结果渲染至DOM</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dashboard</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div id=<span class="string">"dashboard"</span> className=<span class="string">"animated fadeIn"</span>&gt;</span><br><span class="line">        &lt;Timer store=&#123;storeInstance&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p><img src="/Web/Flux/mobx-with-react.gif"></p>
<h3 id="计算值-computed">计算值 computed</h3>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; observable, computed &#125; <span class="keyword">from</span> <span class="string">"mobx"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; observer &#125; <span class="keyword">from</span> <span class="string">"mobx-react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">  @observable price = <span class="number">100</span>;</span><br><span class="line">  @observable amount = <span class="number">200</span>;</span><br><span class="line">  <span class="comment">// 在类属性的getter上通过@computed装饰器创建计算属性</span></span><br><span class="line">  @computed <span class="keyword">get</span> total() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.price * <span class="keyword">this</span>.amount;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> storeOrder = <span class="keyword">new</span> Store();</span><br><span class="line"></span><br><span class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 随机更新observable的属性值，然后观察计算属性total的变化</span></span><br><span class="line">  storeOrder.price += <span class="built_in">Math</span>.random();</span><br><span class="line">&#125;, <span class="number">1500</span>);</span><br><span class="line"></span><br><span class="line">@observer</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>实时价格: &#123;this.props.store.total&#125; <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dashboard</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div id=<span class="string">"dashboard"</span> className=<span class="string">"animated fadeIn"</span>&gt;</span><br><span class="line">        &lt;Counter store=&#123;storeOrder&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p><img src="/Web/Flux/mobx-with-computed.gif"></p>
<blockquote>
<p>Mobx 相对于 Redux，最大的进步在于将 Redux 当中繁琐的 Reducer 声明进行了简化，通过类似于 VueX 的显式双向绑定方式，实时将需要更新的值反映至相应组件，是一款现代化 Flux 框架的正确打开方式。</p>
</blockquote>
<h2 id="vuex">Vuex</h2>
<p>Vuex 是由 Vue 前端生态圈提出的一种应用状态管理库，能够与 Vue 无缝进行集成。如果关闭其严格模式，则不需要再书写繁琐的 Mutation（<em>类似于 Redux 中 Reducer 的作用</em>），而直接将 Vuex 的<code>store</code>与 Vue 组件的<code>data</code>进行响应式绑定，这个对于单张页面内多组件间存在大量交互数据的场景非常有用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> appStore = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  strict: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="state">State</h3>
<p>和 React 生态圈下的 Flux 解决方案一样，Vuex 同样通过一个状态对象管理全部的应用状态，换而言之，每个应用将仅包含一个<code>Store</code>实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    users: [</span><br><span class="line">      &#123; <span class="attr">username</span>: <span class="string">"hank"</span>, <span class="attr">password</span>: <span class="string">"123"</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">username</span>: <span class="string">"uinika"</span>, <span class="attr">password</span>: <span class="string">"456"</span> &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="getter">Getter</h3>
<p>Vuex 允许在<code>Store</code>定义<code>getter</code>，其作用类似于前面提到的 Mobx 的<code>@computed</code>计算属性。<code>getter</code>返回值会根据其所依赖的状态进行缓存，只有该依赖状态发生了变化的情况下才会重新计算。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    users: [</span><br><span class="line">      &#123; <span class="attr">username</span>: <span class="string">"hank"</span>, <span class="attr">password</span>: <span class="string">"123"</span>, <span class="attr">isLogin</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">username</span>: <span class="string">"uinika"</span>, <span class="attr">password</span>: <span class="string">"456"</span>, <span class="attr">isLogin</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    doneTodos: <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.isLogin.filter(<span class="function">(<span class="params">user</span>) =&gt;</span> user.isLogin);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="mutation">Mutation</h3>
<p>开启严格模式的情况下，Vuex 更改<code>Store</code>中的状态的唯一方法是提交<code>mutation</code>，其作用和用法类似于 Redux 中的<code>reducer</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    user: &#123; <span class="attr">username</span>: <span class="string">"hank"</span>, <span class="attr">password</span>: <span class="string">"123"</span>, <span class="attr">isLogin</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    login(state) &#123;</span><br><span class="line">      <span class="comment">// 变更状态</span></span><br><span class="line">      state.user.isLogin = <span class="literal">true</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">store.commit(<span class="string">"login"</span>); <span class="comment">// 提交Mutation</span></span><br></pre></td></tr></table></figure>
<h3 id="action-2">Action</h3>
<p>类 Flux 框架，总是少不了 Action 的存在，Vuex 中<code>action</code>与<code>mutation</code>的不同之处在于：<code>action</code>只能提交<code>mutation</code>，而不能直接对<code>store</code>进行修改，副作用的操作（<em>例如异步的请求</em>）可以书写在<code>action</code>当中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    user: &#123; <span class="attr">username</span>: <span class="string">"hank"</span>, <span class="attr">password</span>: <span class="string">"123"</span>, <span class="attr">isLogin</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    login(state) &#123;</span><br><span class="line">      <span class="comment">// 变更状态</span></span><br><span class="line">      state.user.isLogin = <span class="literal">true</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    login(context) &#123;</span><br><span class="line">      context.commit(<span class="string">"login"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">store.commit(<span class="string">"login"</span>); <span class="comment">// 提交并触发Mutation</span></span><br><span class="line">store.dispatch(<span class="string">"login"</span>); <span class="comment">// 提交并触发Action</span></span><br></pre></td></tr></table></figure>
<h3 id="module">Module</h3>
<p>在应用较为复杂的场景下，单一的<code>Store</code>对象可能变得非常臃肿，因此有必要通过模块化进行更细粒度的划分。Vuex 提出的模块化<code>Store</code>为此提供了非常良好的体验，允许将<code>Store</code>分割为模块（<em>module</em>），每个模块拥有自己的<code>state</code>、<code>mutation</code>、<code>action</code>、<code>getter</code>甚至嵌套的子模块。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> module1 = &#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> module2 = &#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: module1,</span><br><span class="line">    b: module2,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">store.state.a; <span class="comment">// module1的状态</span></span><br><span class="line">store.state.b; <span class="comment">// module2的状态</span></span><br></pre></td></tr></table></figure>
<h3 id="结构良好的-vuex-项目">结构良好的 Vuex 项目</h3>
<p>添加 Vuex 热重载与模块化支持，并将嵌套的子<code>Store</code>解耦至子组件的代码目录，便于查看与管理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">"vuex"</span>;</span><br><span class="line"><span class="keyword">import</span> Demo <span class="keyword">from</span> <span class="string">"./demo/script.store"</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  strict: process.env.NODE_ENV !== <span class="string">"production"</span>,</span><br><span class="line">  modules: &#123;</span><br><span class="line">    Demo, <span class="comment">// 声明模块</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">  <span class="built_in">module</span>.hot.accept([<span class="string">"./store"</span>, <span class="string">"./demo/script.store"</span>], () =&gt; &#123;</span><br><span class="line">    Store.hotUpdate(&#123;</span><br><span class="line">      modules: &#123;</span><br><span class="line">        Demo: <span class="built_in">require</span>(<span class="string">"./demo/script.store"</span>).default,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">"Vue hot update!"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  Store,</span><br><span class="line">&#125;).$mount(<span class="string">"#app"</span>);</span><br></pre></td></tr></table></figure>
<p>嵌套的子<code>Store</code>中需要使用<code>namespaced: true,</code>开启模块命名空间，所有<code>getter</code>、<code>action</code>、<code>mutation</code>都会根据模块注册的路径调整命名。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  namespaced: <span class="literal">true</span>,</span><br><span class="line">  state: &#123;</span><br><span class="line">    data1: &#123;&#125;,</span><br><span class="line">    data2: [],</span><br><span class="line">    loading: <span class="literal">false</span>, <span class="comment">// 加载动画</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>除此之外，Vuex 提供的一系列 mapper 语法糖能够便捷的融合 Vuex 的各类特性，有着良好的书写体验与开发效率。整体来看，Vuex 是过去诸多 Flux 框架实现的集大成者，对 React 生态下 Mobx 的开发有着非常深刻的影响，堪称<strong>现代化 Flux 框架实现的典范</strong>。</p>
<h2 id="fsa">FSA</h2>
<p>Redux 社区制订了<a href="https://github.com/redux-utilities/flux-standard-action" target="_blank" rel="noopener">《Flux Standard Action》</a>规范，这是一套人机友好并且较为通用的<code>Action</code>对象定义规范，下面代码是一个满足<strong>FSA</strong>标准的 Action 对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: <span class="string">'UPDATE'</span>,</span><br><span class="line">  payload: <span class="keyword">new</span> <span class="built_in">Error</span>(),</span><br><span class="line">  error: <span class="literal">true</span>，</span><br><span class="line">  meta: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>诸多 Flux 实现在处理异步队列时，往往会增加<code>FETCH_SUCCESS</code>和<code>FETCH_FAILURE</code>两个 Action 类型，这样的方式其实并不理想，因为它重载了 2 个独立的关注点：标识 action 是否需要表达错误、从全局 action 队列中消除某一类型 Action 的歧义，而在 FSA 当中会将<code>error</code>视为头等概念。</p>
</blockquote>
<p>FSA 标准主要为了达成如下 3 个设计目标：</p>
<ol type="1">
<li><strong>简单</strong>：对象结构简单、直接、灵活。</li>
<li><strong>人性化</strong>：便于开发人员编写和阅读。</li>
<li><strong>有效</strong>：Action 该能够创建有用的工具和进行抽象。</li>
</ol>
<h3 id="type">type</h3>
<p><code>action</code>的<code>type</code>属性用于指明发生动作的性质，通常是一个字符串常量。如果两种类型是相同的，那么其<code>type</code>属性必须（<em>通过<code>===</code></em>）严格等价。</p>
<h3 id="payload">payload</h3>
<p>可选的<code>payload</code>属性用于表示动作的有效载荷，可以是任何类型的值。任何非表达类型或状态的 Action 相关信息，都应该是<code>payload</code>的一部分。如果<code>error</code>属性为<code>true</code>，那么<code>payload</code>属性应该是一个<em>错误对象</em>，类似于拒绝一个带有错误对象的 Promise。</p>
<h3 id="error">error</h3>
<p>可选的<code>error</code>属性用于在<code>action</code>出现错误的时候被设置为<code>true</code>，主要起到一个错误标志位的作用。因为根据上面的约定，<strong>错误对象</strong>本身需要放置到<code>payload</code>属性上。如果<code>error</code>属性拥有除<code>true</code>之外的其它值（<em><code>undefined</code>或<code>null</code></em>），则<code>action</code>并不能被解析为错误。</p>
<h3 id="meta">meta</h3>
<p>可选的<code>meta</code>元属性可以是任何类型的值，主要用于放置一些额外的信息，并非有效载荷<code>payload</code>的一部分。</p>
<h3 id="fsa-提供的工具函数">FSA 提供的工具函数</h3>
<p>FSA 提供了<a href="https://www.npmjs.com/package/flux-standard-action" target="_blank" rel="noopener">flux-standard-action</a>项目，可以通过下面命令安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i flux-standard-action --save</span><br></pre></td></tr></table></figure>
<p>该 npm 包提供了如下 2 个辅助函数：</p>
<ul>
<li><code>isFSA(action)</code>：判断<code>action</code>是否满足 FSA 标准。</li>
<li><code>isError(action)</code>：<code>action</code>出现错误的时候返回<code>true</code>。</li>
</ul>
<blockquote>
<p><a href="https://github.com/acdlite/redux-actions" target="_blank" rel="noopener">redux-actions</a>、<a href="https://github.com/acdlite/redux-promise" target="_blank" rel="noopener">redux-promise</a>、<a href="https://github.com/acdlite/redux-rx" target="_blank" rel="noopener">redux-rx</a>等第三方库都遵循了 FSA 规范。</p>
</blockquote>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Hank
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://uinika.github.io/Web/Flux.html" title="Flux 数据流两三事儿">https://uinika.github.io/Web/Flux.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/JavaScript/" rel="tag"><i class="fa fa-tag"></i> JavaScript</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/Web/Html.html" rel="prev" title="概览 HTML 5 语义化标签">
      <i class="fa fa-chevron-left"></i> 概览 HTML 5 语义化标签
    </a></div>
      <div class="post-nav-item">
    <a href="/Web/Electron.html" rel="next" title="使用 Electron 打造跨平台桌面应用">
      使用 Electron 打造跨平台桌面应用 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#flux"><span class="nav-number">1.</span> <span class="nav-text">Flux</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单向数据流"><span class="nav-number">1.1.</span> <span class="nav-text">单向数据流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dispatcher"><span class="nav-number">1.2.</span> <span class="nav-text">Dispatcher</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#store"><span class="nav-number">1.3.</span> <span class="nav-text">Store</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#view"><span class="nav-number">1.4.</span> <span class="nav-text">View</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#action"><span class="nav-number">1.5.</span> <span class="nav-text">Action</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#reflux"><span class="nav-number">2.</span> <span class="nav-text">Reflux</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#建立-action"><span class="nav-number">2.1.</span> <span class="nav-text">建立 Action</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异步-action-处理"><span class="nav-number">2.2.</span> <span class="nav-text">异步 Action 处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#建立-store"><span class="nav-number">2.3.</span> <span class="nav-text">建立 Store</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#连接-react-组件和-store"><span class="nav-number">2.4.</span> <span class="nav-text">连接 React 组件和 Store</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redux"><span class="nav-number">3.</span> <span class="nav-text">Redux</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本原则"><span class="nav-number">3.1.</span> <span class="nav-text">基本原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#action-1"><span class="nav-number">3.2.</span> <span class="nav-text">Action</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reducer"><span class="nav-number">3.3.</span> <span class="nav-text">Reducer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#store-1"><span class="nav-number">3.4.</span> <span class="nav-text">Store</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#middleware-与-thunk"><span class="nav-number">3.5.</span> <span class="nav-text">Middleware 与 Thunk</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#连接-redux-与-react"><span class="nav-number">3.6.</span> <span class="nav-text">连接 Redux 与 React</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mobx"><span class="nav-number">4.</span> <span class="nav-text">Mobx</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本概念"><span class="nav-number">4.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简单例子"><span class="nav-number">4.2.</span> <span class="nav-text">简单例子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结合-react-使用"><span class="nav-number">4.3.</span> <span class="nav-text">结合 React 使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#计算值-computed"><span class="nav-number">4.4.</span> <span class="nav-text">计算值 computed</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vuex"><span class="nav-number">5.</span> <span class="nav-text">Vuex</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#state"><span class="nav-number">5.1.</span> <span class="nav-text">State</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#getter"><span class="nav-number">5.2.</span> <span class="nav-text">Getter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mutation"><span class="nav-number">5.3.</span> <span class="nav-text">Mutation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#action-2"><span class="nav-number">5.4.</span> <span class="nav-text">Action</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#module"><span class="nav-number">5.5.</span> <span class="nav-text">Module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结构良好的-vuex-项目"><span class="nav-number">5.6.</span> <span class="nav-text">结构良好的 Vuex 项目</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fsa"><span class="nav-number">6.</span> <span class="nav-text">FSA</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#type"><span class="nav-number">6.1.</span> <span class="nav-text">type</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#payload"><span class="nav-number">6.2.</span> <span class="nav-text">payload</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#error"><span class="nav-number">6.3.</span> <span class="nav-text">error</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#meta"><span class="nav-number">6.4.</span> <span class="nav-text">meta</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fsa-提供的工具函数"><span class="nav-number">6.5.</span> <span class="nav-text">FSA 提供的工具函数</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Hank"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Hank</p>
  <div class="site-description" itemprop="description">My world of IT, learn it & play it.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">56</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/uinika" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;uinika" rel="noopener" target="_blank"><i class="fa fa-fw fa-github-alt"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/uinika/posts" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;uinika&#x2F;posts" rel="noopener" target="_blank"><i class="fa fa-fw fa-quora"></i>知乎</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:uinika@outlook.com" title="Email → mailto:uinika@outlook.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>Email</a>
      </span>
      <span class="links-of-author-item">
        <a href="skype:uinika@outlook.com?call|chat" title="Skype → skype:uinika@outlook.com?call|chat" rel="noopener" target="_blank"><i class="fa fa-fw fa-skype"></i>Skype</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/7998979/uinika?tab=profile" title="Stack Overflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;7998979&#x2F;uinika?tab&#x3D;profile" rel="noopener" target="_blank"><i class="fa fa-fw fa-stack-overflow"></i>Stack Overflow</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2010 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"><a rel="license noopener" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a></span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">1.7m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">25:45</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
