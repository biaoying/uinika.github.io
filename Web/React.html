<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#8C634F">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/favicon.png" color="#8C634F">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Monda:300,300italic,400,400italic,700,700italic|Source+Code+Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"uinika.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#A38272","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="全文翻译自React 16.6.0 英文文档，适当精简了生产环境不经常使用的内容，并对部分较为复杂的概念进行了更加翔实的解读，以及与 Vue2 进行了一些特性方面的比较。本文首先会介绍React 16带来的一系列变化与新特性，然后解读 React 官方文档Docs当中Quick Start和Advanced Guides的内容，最后基于项目上的使用实践，开源了一个较为完整的脚手架项目Rhino，适">
<meta property="og:type" content="article">
<meta property="og:title" content="React 16.6.x 全新全译">
<meta property="og:url" content="https://uinika.github.io/Web/React.html">
<meta property="og:site_name" content="Bit by bit">
<meta property="og:description" content="全文翻译自React 16.6.0 英文文档，适当精简了生产环境不经常使用的内容，并对部分较为复杂的概念进行了更加翔实的解读，以及与 Vue2 进行了一些特性方面的比较。本文首先会介绍React 16带来的一系列变化与新特性，然后解读 React 官方文档Docs当中Quick Start和Advanced Guides的内容，最后基于项目上的使用实践，开源了一个较为完整的脚手架项目Rhino，适">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://uinika.github.io/Web/React/logo.png">
<meta property="og:image" content="https://uinika.github.io/Web/React/elements-update.gif">
<meta property="og:image" content="https://uinika.github.io/Web/React/lifecycle.png">
<meta property="og:image" content="https://uinika.github.io/Web/React/state-update.gif">
<meta property="og:image" content="https://uinika.github.io/Web/React/event-toggle.gif">
<meta property="og:image" content="https://uinika.github.io/Web/React/conditional-rendering.gif">
<meta property="og:image" content="https://uinika.github.io/Web/React/prevent-component-render.gif">
<meta property="og:image" content="https://uinika.github.io/Web/React/lifting-state-up.gif">
<meta property="og:image" content="https://uinika.github.io/Web/React/composition-inheritance-1.png">
<meta property="og:image" content="https://uinika.github.io/Web/React/composition-inheritance-2.png">
<meta property="og:image" content="https://uinika.github.io/Web/React/thinking-in-react-components.png">
<meta property="og:image" content="https://uinika.github.io/Web/React/thinking-in-react-mock.gif">
<meta property="og:image" content="https://uinika.github.io/Web/React/portals.gif">
<meta property="og:image" content="https://uinika.github.io/Web/React/error-boundaries-stack-trace.png">
<meta property="og:image" content="https://uinika.github.io/Web/React/error-boundaries-stack-trace-line-numbers.png">
<meta property="article:published_time" content="2020-05-21T13:39:03.860Z">
<meta property="article:modified_time" content="2020-05-21T13:39:03.860Z">
<meta property="article:author" content="Hank">
<meta property="article:tag" content="JavaScript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://uinika.github.io/Web/React/logo.png">

<link rel="canonical" href="https://uinika.github.io/Web/React.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>React 16.6.x 全新全译 | Bit by bit</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Bit by bit" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Bit by bit</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Electronics, Embedded & Web</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-th-large"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">53</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">22</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-briefcase"></i>分类<span class="badge">11</span></a>

  </li>
        <li class="menu-item menu-item-it圈">

    <a href="/industry/" rel="section"><i class="fa fa-fw fa-microchip"></i>IT圈</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/uinika" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://uinika.github.io/Web/React.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hank">
      <meta itemprop="description" content="My world of IT, learn it & play it.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bit by bit">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          React 16.6.x 全新全译
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-21 21:39:03" itemprop="dateCreated datePublished" datetime="2020-05-21T21:39:03+08:00">2020-05-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web/" itemprop="url" rel="index"><span itemprop="name">Web</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>87k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:19</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>全文翻译自<a href="https://reactjs.org/" target="_blank" rel="noopener">React 16.6.0 英文文档</a>，适当精简了生产环境不经常使用的内容，并对部分较为复杂的概念进行了更加翔实的解读，以及与 Vue2 进行了一些特性方面的比较。本文首先会介绍<strong>React 16</strong>带来的一系列变化与新特性，然后解读 React 官方文档<a href="https://reactjs.org/docs/hello-world.html" target="_blank" rel="noopener">Docs</a>当中<strong>Quick Start</strong>和<strong>Advanced Guides</strong>的内容，最后基于项目上的使用实践，开源了一个较为完整的<strong><a href="https://github.com/uinika/rhino.git" target="_blank" rel="noopener">脚手架项目Rhino</a></strong>，适合已经具备<strong>组件式</strong>前端框架开发经验的同学快速上手。</p>
<p><img src="/Web/React/logo.png"></p>
<p>2017 年 9 月 <strong>Facebook</strong> 释出<code>React v16.0.x</code>，宣布使用对商业使用更加友好的 <a href="https://mit-license.org/" target="_blank" rel="noopener"><strong>MIT license</strong></a> 开源许可，并带来了全新的<code>render()</code>函数返回类型、更加健壮的错误处理机制、全新的<code>Fragment</code>和<code>Portal</code> 特性，并完全重写了类库的核心架构，带来更为优异服务器端渲染性能的同时，有效缩小了类库代码本身的体积，更重要的意义在于杜绝了 <a href="https://github.com/developit/preact" target="_blank" rel="noopener"><strong>Preact</strong></a> 等衍生框架对 React 社区所造成的分裂。</p>
<a id="more"></a>
<h1 id="快速开始">快速开始</h1>
<p>如果使用 npm 作为依赖管理工具，可以通过下面命令安装 React。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save react react-dom</span><br></pre></td></tr></table></figure>
<p>一个使用 ES6 的最简单例子是这样的：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, React 16.6.0 !<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">"app"</span>));</span><br></pre></td></tr></table></figure>
<p>当然，也可以使用独立的 React 发布包，直接在<code>&lt;script&gt;</code>标签当中包含使用。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Development Versions--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">crossorigin</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/react@16/umd/react.development.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">crossorigin</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/react-dom@16/umd/react-dom.development.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Production Versions --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">crossorigin</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/react@16/umd/react.production.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">crossorigin</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="jsx-语法">JSX 语法</h1>
<p>JSX 是一个具有<strong>JavaScript 编程特性</strong>的<strong>类 HTML 标签</strong>语言，目前<em>TypeScript</em>和<em>Vue2</em>都已经对 JSX 语法提供了良好的支持，广泛的应用于现代化前端应用开发当中。</p>
<h2 id="向-jsx-中嵌入表达式">向 JSX 中嵌入表达式</h2>
<p>开发人员可以通过花括号语法<code>{}</code>嵌入 JavaScript 表达式（<em>例如<code>2+2</code>、<code>user.name</code>、<code>auth(user)</code></em>）。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">auth</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> user.name + <span class="string">" "</span> + user.password;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  name: <span class="string">"hank"</span>,</span><br><span class="line">  password: <span class="string">"12345"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;h1&gt;</span><br><span class="line">    User Info：</span><br><span class="line">    &#123;auth(user)&#125;.</span><br><span class="line">  &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(element, document.getElementById("app"));</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过使用圆括号语法<code>()</code>，可以方便的书写多行 JSX。</p>
</blockquote>
<h2 id="jsx-本身也是一种表达式">JSX 本身也是一种表达式</h2>
<p><strong>编译之后，JSX 表达式会被转换为标准的 JavaScript 对象</strong>，这意味可以在 JSX 内使用<code>if</code>和<code>for</code>等 JavaScript 语句、指定一个变量、接收其作为参数、甚至是从一个函数当中返回它们。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserInfo</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (user) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;h1&gt;</span><br><span class="line">        User Info：</span><br><span class="line">        &#123;auth(user)&#125;</span><br><span class="line">      &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  return &lt;h1&gt;No Info.&lt;/</span>h1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="指定-jsx-的属性">指定 JSX 的属性</h2>
<p>可以使用引号<code>"</code>指定一个字符串字面量作为 JSX 的属性。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element1 = <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"dashboard"</span> /&gt;</span></span>;</span><br><span class="line"><span class="keyword">const</span> element2 = <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">tabIndex</span>=<span class="string">"0"</span> /&gt;</span></span>;</span><br></pre></td></tr></table></figure>
<p>也可以使用花括号表达式<code>{}</code>嵌入 JavaScript 表达式到 JSX 属性当中，此时无需在花括号外使用引号。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;user.avatarUrl&#125;</span> /&gt;</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>相比于静态的 HTML，由于 JSX 编程性上更加接近于 JavaScript，React DOM 使用驼峰风格（<em>camelCase</em>）的属性名称来代替原生 HTML 属性风格，例如：HTML 中的<code>class</code>和<code>tabindex</code>变为 JSX 中的<code>className</code>以及<code>tabIndex</code>。</p>
</blockquote>
<h2 id="使用-jsx-指定子元素">使用 JSX 指定子元素</h2>
<p>如果 JSX 标签内容为空，可以使用<code>/&gt;</code>直接进行关闭。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;user.avatarUrl&#125;</span> /&gt;</span></span>;</span><br></pre></td></tr></table></figure>
<p>当然，JSX 标签可能也会包含子元素 ，如同下面这样：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;Hello!&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;h2&gt;React 16.6.0!&lt;/</span>h2&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure>
<h2 id="jsx-可以预防脚本注入攻击">JSX 可以预防脚本注入攻击</h2>
<p>React DOM 默认会在 JSX 渲染之前，避免任何值嵌入。因此可以确保不会被注入显式编写在应用之外的内容。为了避免 XSS 跨站脚本攻击，任何内容在渲染之前都会被转换为字符串。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> text = response.dangerInput;</span><br><span class="line"><span class="comment">// 这里是安全的</span></span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;text&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="jsx-最终会被转换为对象">JSX 最终会被转换为对象</h2>
<p>Babel 会将 JSX 编译为一个<code>React.createElement()</code>函数调用，因此下面代码中的<code>element1</code>与<code>element2</code>是等效的。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element1 = <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">"demo"</span>&gt;</span>你好, React 16.6.0！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element2 = React.createElement(<span class="string">"h1"</span>, &#123; <span class="attr">className</span>: <span class="string">"demo"</span> &#125;, <span class="string">"你好, React 16.6.0！"</span>);</span><br></pre></td></tr></table></figure>
<p>虽然<code>React.createElement()</code>会执行各类检查帮助你编写准确无误的代码，但是本质上其建立的对象是下面的样子：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了方便理解，下面对象经过了简化处理</span></span><br><span class="line"><span class="keyword">const</span> element = &#123;</span><br><span class="line">  type: <span class="string">"h1"</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    className: <span class="string">"demo"</span>,</span><br><span class="line">    children: <span class="string">"你好, React 16.6.0！"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这些对象被称为<strong>React elements</strong>，React 读取这些对象并通过它们去构建 DOM，并负责维护其状态，其名称乃至于功能都与 Vue2 模板编译所使用的<code>createElement()</code>函数一致。</p>
<h1 id="元素-elements">元素 Elements</h1>
<p><strong>元素 Elements</strong>是 React 应用的最小组成部份，不同于浏览器的 DOM 元素，React 元素是一个非常易于建立的普通对象。React 的组件（<em>Components</em>）和元素（<em>Elements</em>）是非常容易混淆的两个概念，事实上<strong>React 的组件是由元素所组成的，元素是 React 的 JSX 模板的最小组成部分</strong>。</p>
<h2 id="渲染一个-react-元素到-dom">渲染一个 React 元素到 DOM</h2>
<p>通过<code>ReactDOM.render()</code>方法渲染一个 React 元素到 HTML 的 DOM 根结点。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, React 16.6.0 !<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(element, <span class="built_in">document</span>.getElementById(<span class="string">"app"</span>));</span><br></pre></td></tr></table></figure>
<h2 id="更新已经被渲染的-react-元素">更新已经被渲染的 React 元素</h2>
<p>React 元素是不可变的，建立后就不能修改其<strong>属性</strong>以及<strong>子元素</strong>。React 元素就像电影中的一个关键帧，总是在确切的时间点展现 UI。</p>
<p>更新 UI 总是需要去建立一个新的 React 元素，然后再通过<code>ReactDOM.render()</code>渲染出来。例如下面代码，每间隔 1 秒钟使用<code>setInterval()</code>回调函数执行<code>ReactDOM.render()</code>方法。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> element = (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;你好, React <span class="number">16.6</span><span class="number">.0</span> !&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;h2&gt;</span></span><br><span class="line"><span class="regexp">        现在时间是</span></span><br><span class="line"><span class="regexp">        &#123;new Date().toLocaleTimeString()&#125;。</span></span><br><span class="line"><span class="regexp">      &lt;/</span>h2&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">  ReactDOM.render(element, document.getElementById("app"));</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">setInterval(timer, 1000);</span></span><br></pre></td></tr></table></figure>
<h2 id="react-元素是按需更新的">React 元素是按需更新的</h2>
<p>React DOM 会比较当前 React 元素与其之前的状态，然后只对发生变化的 DOM 局部执行更新操作。</p>
<p><img src="/Web/React/elements-update.gif" title="React只对变化的那部分DOM内容进行更新"></p>
<h1 id="components-组件">Components 组件</h1>
<p><strong>组件 Components</strong>可以将 UI 拆分为独立且可复用的片断，React 组件接收<code>props</code>作为输入参数，并在最后返回 React 元素。</p>
<h2 id="函数式组件与类组件">函数式组件与类组件</h2>
<p>定义 React 组件最简单的方法是通过 JavaScript 函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收props参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>你好, &#123;props.name&#125;！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>; <span class="comment">// 返回React元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然也可以通过 ES6 的<code>class</code>关键字定义一个等效组件，从而获取更多的有趣特性。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>你好, &#123;this.props.name&#125;！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="渲染一个组件">渲染一个组件</h2>
<p>首先定义一个 React 组件，然后将组件赋值给一个 React 元素，最后再使用<code>ReactDOM.render()</code>方法渲染该 React 元素到页面上。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个函数式组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>你好, &#123;props.name&#125;！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将上面定义的组件赋予一个React元素</span></span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">Welcome</span> <span class="attr">name</span>=<span class="string">"Hank"</span> /&gt;</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染这个元素</span></span><br><span class="line">ReactDOM.render(element, <span class="built_in">document</span>.getElementById(<span class="string">"app"</span>));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>React 组件的名称通常约定为<strong>大写</strong>格式。</p>
</blockquote>
<h2 id="组合使用多个组件">组合使用多个组件</h2>
<p>我们可以在一个组件返回的 JSX 当中组合引用其它的组件。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>你好, &#123;props.name&#125;！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Welcome name=<span class="string">"Hank"</span> /&gt;</span><br><span class="line">      &lt;Welcome name=<span class="string">"Jack"</span> /&gt;</span><br><span class="line">      &lt;Welcome name=<span class="string">"Candy"</span> /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">"app"</span>));</span><br></pre></td></tr></table></figure>
<h2 id="组件的抽取">组件的抽取</h2>
<p>可以将一个较大的组件分割为更加细粒度的组件，便于复用与维护，例如下面这个函数式组件<code>Comment</code>：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Comment</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"Comment"</span>&gt;</span><br><span class="line">      &lt;div className=<span class="string">"UserInfo"</span>&gt;</span><br><span class="line">        &lt;img className=<span class="string">"Avatar"</span> src=&#123;props.author.avatarUrl&#125; alt=&#123;props.author.name&#125; /&gt;</span><br><span class="line">        &lt;div className=<span class="string">"UserInfo-name"</span>&gt;&#123;props.author.name&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">      &lt;div className=<span class="string">"Comment-text"</span>&gt;&#123;props.text&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div className="Comment-date"&gt;&#123;formatDate(props.date)&#125;&lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>可以将其拆分为<code>Avatar</code>，<code>UserInfo</code>，<code>Comment</code>三个具有包含关系的组件。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Avatar</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">className</span>=<span class="string">"Avatar"</span> <span class="attr">src</span>=<span class="string">&#123;props.user.avatarUrl&#125;</span> <span class="attr">alt</span>=<span class="string">&#123;props.user.name&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserInfo</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"UserInfo"</span>&gt;</span><br><span class="line">      &lt;Avatar user=&#123;props.user&#125; /&gt;</span><br><span class="line">      &lt;div className=<span class="string">"UserInfo-name"</span>&gt;&#123;props.user.name&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Comment</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"Comment"</span>&gt;</span><br><span class="line">      &lt;UserInfo user=&#123;props.author&#125; /&gt;</span><br><span class="line">      &lt;div className=<span class="string">"Comment-text"</span>&gt;&#123;props.text&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div className="Comment-date"&gt;&#123;formatDate(props.date)&#125;&lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="props-是只读的">Props 是只读的</h2>
<p>无论是以函数式还是<code>class</code>类的方式声明组件，都不能对它们的<code>props</code>进行修改。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pure</span>(<span class="params">firstname, lastname</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> firstname + lastname; <span class="comment">// 没有对props进行修改</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">impure</span>(<span class="params">firstname, lastname</span>) </span>&#123;</span><br><span class="line">  firstname = <span class="string">"nothing"</span>; <span class="comment">// 对props进行了修改，不建议这样做</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>重要原则：组件外部只能通过 props 改变组件本身的行为。</strong></p>
</blockquote>
<h1 id="state-状态">State 状态</h1>
<p>首先，我们来改写之前定时器<code>timer</code>的例子。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> element = (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;你好, React <span class="number">16.6</span><span class="number">.0</span> !&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;h2&gt;</span></span><br><span class="line"><span class="regexp">        现在时间是</span></span><br><span class="line"><span class="regexp">        &#123;new Date().toLocaleTimeString()&#125;。</span></span><br><span class="line"><span class="regexp">      &lt;/</span>h2&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">  ReactDOM.render(element, document.getElementById("app"));</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">setInterval(timer, 1000);</span></span><br></pre></td></tr></table></figure>
<p>然后，将 JSX 元素<code>element</code>从<code>timer()</code>函数中提取出来，并抽象为一个 JSX 组件<code>Clock</code>，然后通过<code>props</code>向组件传递当前<code>date</code>参数。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Clock</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello, world!&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;.&lt;/</span>h2&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function timer() &#123;</span></span><br><span class="line"><span class="regexp">  ReactDOM.render(&lt;Clock date=&#123;new Date()&#125; /</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">"app"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(timer, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>但是，我们希望<code>Clock</code>组件的更新总是来自于其内部状态，而非通过组件外部的<code>props</code>进行传入，如同下面代码这样：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Clock</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">"app"</span>));</span><br></pre></td></tr></table></figure>
<p>这就引出了 React 组件当中的另一个重要概念<strong>state</strong>，<code>state</code>与<code>props</code>非常类似，但是其<strong>属于组件私有，只能由组件自身进行控制</strong>。另外，前面章节有提到<strong>类组件具有比函数式组件更丰富的特性</strong>，而<code>state</code>就是这些特性当中的一个，因为它只能由类组件进行使用。</p>
<h2 id="将函数式组件转换为类组件">将函数式组件转换为类组件</h2>
<p>首先，需要建立一个继承自<code>React.Component</code>ES6 的 Class 类，并添加一个<code>render()</code>方法；然后将组件内容移动至该方法当中，并将函数式组件中传入的<code>props</code>参数，修改为通过<code>this.props</code>进行引用。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;h2&gt;It is &#123;this.props.date.toLocaleTimeString()&#125;.&lt;/</span>h2&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="向类组件添加-state">向类组件添加 state</h2>
<p>首先，将<code>render()</code>函数中的<code>this.props.date</code>替换为<code>this.state.date</code>。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/</span>h2&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>然后，定义一个<code>constructor()</code>构造方法去初始化<code>this.state</code>。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 注意这里是如何将props传递到构造函数中的</span></span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props); <span class="comment">// 类组件总是会使用props作为参数调用基类构造器。</span></span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>() &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/</span>h2&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>最后，从<code>&lt;Clock /&gt;</code>元素移除作为<code>props</code>的<code>date</code>属性。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Clock</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">"app"</span>));</span><br></pre></td></tr></table></figure>
<p>最终结果看起来是下面这样的：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>() &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/</span>h2&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Clock /</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">"app"</span>));</span><br></pre></td></tr></table></figure>
<p>接下来，我们需要利用 React 组件提供的<strong>生命周期方法</strong>，每间隔 1 秒对当前显示的时间进行更新。</p>
<h1 id="生命周期钩子">生命周期钩子</h1>
<p>组件式前端框架通常都会拥有自己特定的生命周期函数，从过去的<code>Backbone</code>、<code>Ember</code>到更为现代化的<code>Vue2</code>、<code>Angular6</code>皆是如此，同样作为组件式框架的React也不例化。总体上，React的生命周期可以分为如下四个阶段：</p>
<p><strong>装载</strong>（<em>Mounting</em>），组件实例被创建并插入 DOM 时会按下面顺序调用方法：</p>
<ul>
<li><code>constructor()</code></li>
<li><code>static getDerivedStateFromProps()</code></li>
<li><code>render()</code></li>
<li><code>componentDidMount()</code></li>
</ul>
<p><strong>更新</strong>（<em>Updating</em>），修改<code>props</code>或<code>state</code>时会触发组件的更新，此时会依照如下顺序调用方法：</p>
<ul>
<li><code>static getDerivedStateFromProps()</code></li>
<li><code>shouldComponentUpdate()</code></li>
<li><code>render()</code></li>
<li><code>getSnapshotBeforeUpdate()</code></li>
<li><code>componentDidUpdate()</code></li>
</ul>
<p><strong>卸载</strong>（<em>Unmounting</em>），当组件从 DOM 中被删除时调用该方法：</p>
<ul>
<li><code>componentWillUnmount()</code></li>
</ul>
<p><strong>错误处理</strong>（<em>Error Handling</em>），在生命周期方法、子组件构造函数、组件渲染过程中出现错误时会调用下列方法：</p>
<ul>
<li><code>static getDerivedStateFromError()</code></li>
<li><code>componentDidCatch()</code></li>
</ul>
<figure>
<img src="/Web/React/lifecycle.png" alt><figcaption>lifecycle</figcaption>
</figure>
<p>多组件应用程序开发当中，非常重要的一点在于：<strong>在组件被销毁的时候去释放组件占用的资源</strong>。即当组件被渲染至 DOM 的时候，需要初始化<code>Clock</code>组件中的定时器，React 生命周期中称为<code>mounting挂载</code>；然后在组件被销毁时，清除组件定时器所占用的资源，React 生命周期中称为<code>unmounting卸载</code>。下面详细讲解一下React 中提供的两个比较重要的<strong>生命周期钩子（<em>lifecycle hooks</em>）</strong>：<code>componentDidMount()</code>和<code>componentWillUnmount()</code>。</p>
<h2 id="componentdidmount钩子">componentDidMount()钩子</h2>
<p>React 组件被渲染到 HTML DOM 后被执行，可以用来初始化之前例子中的定时器。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  <span class="comment">// 设置timer ID到this指针</span></span><br><span class="line">  <span class="keyword">this</span>.timerID = setInterval(</span><br><span class="line">    () =&gt; <span class="keyword">this</span>.tick(),</span><br><span class="line">    <span class="number">1000</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="componentwillunmount钩子">componentWillUnmount()钩子</h2>
<p>React 组件从 HTML DOM 卸载之前得到执行，可以用来销毁定义在组件<code>this</code>上的定时器。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">componentWillUnmount() &#123;</span><br><span class="line">  clearInterval(<span class="keyword">this</span>.timerID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="抽取-timer函数">抽取 timer()函数</h2>
<p><code>timer()</code>函数会通过<code>this.setState()</code>定时更新组件本身的<code>state</code>，从而动态展示当前时间。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>() &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.timerID = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.timer(), <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    clearInterval(<span class="keyword">this</span>.timerID);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  timer() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      date: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/</span>h2&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Clock /</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">"app"</span>));</span><br></pre></td></tr></table></figure>
<h1 id="深入-state">深入 State</h1>
<p>除了在类组件的构造函数之外，不允许直接修改<code>state</code>，而必须通过组件提供的<code>setState()</code>方法执行修改操作。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">this</span>.state.comment = <span class="string">"你好"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123; <span class="attr">comment</span>: <span class="string">"你好"</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>React 中<code>this.props</code>和<code>this.state</code>的更新都是<strong>异步</strong>的，当在同一个组件中多次应用时，不能依赖它们去计算下一个状态（<em>可能会造成错误</em>），例如下面代码可能会错误的更新计数器：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">  counter: <span class="keyword">this</span>.state.counter + <span class="keyword">this</span>.props.increment</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>要修复这个问题，<code>setState()</code>可以接收一个函数作为参数，该函数第 1 个参数是之前的<code>state</code>，第 2 个参数是<code>props</code>。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> (&#123;</span><br><span class="line">  counter: prevState.counter + props.increment</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p>通过<code>setState()</code>对 state 的更新操作都会合并到当前的 State 状态，例如下面代码的<code>state</code>中可以包含多个独立值：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">  <span class="keyword">super</span>(props);</span><br><span class="line">  <span class="keyword">this</span>.state = &#123;</span><br><span class="line">    users: [],</span><br><span class="line">    groups: []</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后可以在组件里，分别使用<code>setState()</code>对这些值进行单独更新。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  fetchUser().then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      users: response.users</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  fetchGroup().then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      groups: response.groups</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="单向数据流">单向数据流</h1>
<p>React 当中的<code>state</code>通常被认为是<em>局部的</em>或者<em>封装的</em>，除了拥有并设置它的组件之外，其它任何组件都不能对其进行访问。因此，父子组件之间，可以通过将<code>state</code>赋值给<code>props</code>的方式，将父组件的内部状态传递给子组件。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;FormattedDate date=&#123;<span class="keyword">this</span>.state.date&#125; /&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FormattedDate</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>It is &#123;props.date.toLocaleTimeString()&#125;.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码当中的<code>FormattedDate</code>组件通过其 props 接收了父组件传递过来的状态<code>this.state.date</code>。因此，可以认为 React 组件之间的数据流向是从<strong>父组件至子组件</strong>，即一个<strong>由上至下</strong>的关系，通常被称为<strong>单向数据流</strong>，</p>
<blockquote>
<p>可以将一个组件树中的<code>props</code>想象成一个瀑布流，每个单独组件的<code>state</code>如同一个个的独立水源，在任意时间节点加入到瀑布流当中，然后共同向下流动。</p>
</blockquote>
<p>下面代码中，在一个<code>App</code>组件内部渲染了多个<code>Clock</code>组件，每个组件的时间都会独立进行更新，互相不受影响。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Clock /&gt;</span><br><span class="line">      &lt;Clock /&gt;</span><br><span class="line">      &lt;Clock /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">"app"</span>));</span><br></pre></td></tr></table></figure>
<p><img src="/Web/React/state-update.gif" title="每个React组件都会单独更新"></p>
<h1 id="事件机制">事件机制</h1>
<p>React 事件机制与原生 JavaScript 事件机制语法上有以下不同：</p>
<ol type="1">
<li>React 事件名称使用<strong>驼峰命名 camelCase</strong>。</li>
<li>JSX 可以直接使用函数作为事件处理器。</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原生JavaScript事件</span></span><br><span class="line">&lt;button onclick=<span class="string">"activateLasers()"</span>&gt;</span><br><span class="line">  Activate Lasers</span><br><span class="line">&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ React事件</span></span><br><span class="line"><span class="regexp">&lt;button onClick=&#123;activateLasers&#125;&gt;</span></span><br><span class="line"><span class="regexp">  Activate Lasers</span></span><br><span class="line"><span class="regexp">&lt;/</span>button&gt;</span><br></pre></td></tr></table></figure>
<p>（3）React 不能通过返回<code>false</code>阻止事件默认行为，而必须显式调用<code>preventDefault()</code>方法。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">"#"</span> onclick=<span class="string">"console.log('这个链接已经被点击！'); return false"</span>&gt;</span><br><span class="line">  Click me</span><br><span class="line">&lt;<span class="regexp">/a&gt;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function ActionLink() &#123;</span></span><br><span class="line"><span class="regexp">  function handleClick(e) &#123;</span></span><br><span class="line"><span class="regexp">    e.preventDefault();</span></span><br><span class="line"><span class="regexp">    console.log("这个链接已经被点击！");</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;a href="#" onClick=&#123;handleClick&#125;&gt;</span></span><br><span class="line"><span class="regexp">      点击目标</span></span><br><span class="line"><span class="regexp">    &lt;/</span>a&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，传入事件处理函数<code>handleClick(e)</code>的参数<code>e</code>是 React 遵循<a href="https://www.w3.org/TR/DOM-Level-3-Events/" target="_blank" rel="noopener">W3C UI Events 事件规范</a>实现的<strong>合成事件</strong>，因此毋需担心跨浏览器兼容性问题。</p>
<p>使用 ES6 的 class 定义一个类组件时，通用的做法是以<strong>类方法</strong>的形式定义事件处理函数，例如下面代码定义了一个可以点击切换【打开】和【关闭】状态的按钮。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Toggle</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">isToggleOn</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用bind()方法，将this作用域绑定至回调函数</span></span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">prevState</span> =&gt;</span> (&#123;</span><br><span class="line">      isToggleOn: !prevState.isToggleOn</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>&#123;this.state.isToggleOn ? "打开" : "关闭"&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Toggle</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">"app"</span>));</span><br></pre></td></tr></table></figure>
<p><img src="/Web/React/event-toggle.gif" title="切换按钮内容的点击事件"></p>
<p>大家注意理解上面类组件<code>constructor()</code>构造函数当中，<code>this.handleClick.bind(this)</code>的含义。使用<code>bind()</code>是为了将类组件的<code>this</code>作用域绑定至指定函数，从而方便的在该函数内部使用<code>this</code>操作 React 类组件上的其它方法。</p>
<h2 id="绑定组件-this-到事件处理函数">绑定组件 this 到事件处理函数</h2>
<p>当然，如果你认为<code>bind()</code>使用起来又臭又长，这里有 2 种方式可以绕开它：</p>
<p>（1）通过实验性的类属性转换语法（<em>Class properties transform</em>）正确绑定<code>this</code>到事件回调函数当中，不过需要额外安装<code>babel-plugin-transform-class-properties</code>插件支持。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 本质是将一个箭头函数赋值给一个变量</span></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"这是："</span>, <span class="keyword">this</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>点击我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）或者通过箭头函数的方式直接调用事件处理函数。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"这是："</span>, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="comment">// 这样的书写语法可以确保this正确的绑定到handleClick</span></span><br><span class="line">      &lt;button onClick=&#123;e =&gt; <span class="keyword">this</span>.handleClick(e)&#125;&gt;点击我&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这种方式的缺点在于每次不同的事件回调函数被建立时，都会触发 React 组件的重绘（<em>比如下面的 Button</em>），如果此时事件回调传递<code>props</code>到子级组件，则这些组件全部都会发生重绘，从而对页面性能造成影响。因此，React 官方更加推荐<strong>通过组件构造器调用<code>bind()</code></strong>和<strong>类属性语法</strong>这两种方式。</p>
</blockquote>
<h2 id="向事件处理函数传递参数">向事件处理函数传递参数</h2>
<p>通常情况下，我们都需要传递参数到事件处理函数，例如传递每一行的<code>id</code>，下面使用的<code>arrow functions</code>和<code>Function.prototype.bind</code>两种写法都是等效的。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;(e) =&gt; <span class="keyword">this</span>.deleteRow(id, e)&#125;&gt;删除行&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;button onClick=&#123;this.deleteRow.bind(this, id)&#125;&gt;删除行&lt;/</span>button&gt;</span><br></pre></td></tr></table></figure>
<p>第 1 个参数<code>e</code>表示的是 React 事件对象，紧随其后的第 2 个参数即用来表示<code>id</code>。</p>
<h1 id="条件渲染">条件渲染</h1>
<p>React 中的条件渲染类似于 JavaScript 中的条件运算，可以通过<code>if</code>等条件运算符去动态展示元素、组件的状态。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>欢迎回来！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Guest</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>请登录！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过Greeting组件条件渲染上面定义的2个组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Greeting</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isLogged = props.isLogged;</span><br><span class="line">  <span class="keyword">if</span> (isLogged) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">User</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Guest</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Greeting isLogged=&#123;<span class="literal">false</span>&#125; /&gt;, <span class="comment">// 尝试将false改成true，会得到不同的展示结果</span></span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"app"</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="元素变量">元素变量</h2>
<p>可以将 React 元素赋值给一个变量，这样可以方便的在组件内部进行条件渲染。下面例子中的<code>&lt;LoginControl /&gt;</code>组件会根据自身的状态，有条件的渲染<code>&lt;LoginButton /&gt;</code>或<code>&lt;LogoutButton /&gt;</code>以及之前例子中的<code>&lt;Greeting /&gt;</code>组件。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无状态组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LoginButton</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;props.onClick&#125;</span>&gt;</span> 登入 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无状态组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LogoutButton</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;props.onClick&#125;</span>&gt;</span> 登出 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带有状态的组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginControl</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleLoginClick = <span class="keyword">this</span>.handleLoginClick.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.handleLogoutClick = <span class="keyword">this</span>.handleLogoutClick.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">isLogged</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleLoginClick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">isLogged</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  handleLogoutClick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">isLogged</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">let</span> button = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> isLogged = <span class="keyword">this</span>.state.isLogged;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isLogged) &#123;</span><br><span class="line">      button = <span class="xml"><span class="tag">&lt;<span class="name">LogoutButton</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleLogoutClick&#125;</span> /&gt;</span></span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      button = <span class="xml"><span class="tag">&lt;<span class="name">LoginButton</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleLoginClick&#125;</span> /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Greeting isLogged=&#123;isLogged&#125; /&gt; &#123;button&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;LoginControl /</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">"app"</span>));</span><br></pre></td></tr></table></figure>
<p><img src="/Web/React/conditional-rendering.gif" title="条件渲染示例"></p>
<p>声明一个变量和使用<code>if</code>关键字是进行条件渲染非常好的方式，但有些时候可能需要使用到更简短的语法，接下来介绍几种行内的条件渲染方式：</p>
<h2 id="内联条件渲染-运算符">内联条件渲染-&amp;&amp;运算符</h2>
<p>将 JSX 表达式嵌入到一个花括号<code>{}</code>运算符中（<em>表达式中包含了 JavaScript 逻辑和<code>&amp;&amp;</code>操作符</em>），可以方便的将 React 元素包含到条件渲染判断语句当中。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Mailbox</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> unreadMessages = props.unreadMessages;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello!&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &#123;unreadMessages.length &gt; 0 &amp;&amp; &lt;h2&gt;You have &#123;unreadMessages.length&#125; unread messages.&lt;/</span>h2&gt;&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const messages = ["React", "Re: React", "Re:Re: React"];</span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Mailbox unreadMessages=&#123;messages&#125; /</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">"app"</span>));</span><br></pre></td></tr></table></figure>
<p>JavaScript 当中<code>true &amp;&amp; 表达式</code>的结果总是<code>表达式</code>，而<code>false &amp;&amp; 表达式</code>的结果总是<code>false</code>。换而言之，如果条件判断结果为<code>true</code>，则<code>&amp;&amp;</code>运算符右侧的 React 元素将会出现在输出当中，如果为<code>false</code>则 React 会自动跳过不进行任何渲染。</p>
<h2 id="内联条件渲染-三目运算符">内联条件渲染-三目运算符</h2>
<p>另外一种使用内联条件渲染的方式是通过三目运算符<code>condition ? true : false</code>，下面例子中使用它对一小块文本进行了条件渲染。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">const</span> isLogged = <span class="keyword">this</span>.state.isLogged;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      用户 &lt;b&gt;&#123;isLogged ? <span class="string">'已经'</span> : <span class="string">'没有'</span>&#125;&lt;<span class="regexp">/b&gt; 登录.</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三目运算符也可以用于进行多行的条件渲染：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">const</span> isLogged = <span class="keyword">this</span>.state.isLogged;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;isLogged ? (</span><br><span class="line">        &lt;LogoutButton onClick=&#123;<span class="keyword">this</span>.handleLogoutClick&#125; /&gt;</span><br><span class="line">      ) : (</span><br><span class="line">        &lt;LoginButton onClick=&#123;<span class="keyword">this</span>.handleLoginClick&#125; /&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如同 JavaScript 一样，条件渲染的使用完全依照开发团队的习惯和实际工作的需求，但是无论如何都不要书写过于复杂的条件渲染语句，否则可以考虑将条件渲染过程抽象为一个具体的组件。</p>
</blockquote>
<h2 id="阻止组件的渲染">阻止组件的渲染</h2>
<p>极少的情况下，开发人员需要将组件隐藏起来，即便它已经被其它组件渲染出来，如果需要这样做，可以让组件<code>render()</code>函数返回<code>null</code>而非 JSX 的内容。</p>
<p>下面的例子中，组件<code>&lt;WarningBanner /&gt;</code>的渲染依赖于一个名为<code>warn</code>的 props 值，如果其值为<code>false</code>则该组件不会渲染。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">WarningBanner</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!props.warn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"warning"</span>&gt;</span>警告信息！<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Page</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">showWarning</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">    <span class="keyword">this</span>.handleToggleClick = <span class="keyword">this</span>.handleToggleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleToggleClick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">prevState</span> =&gt;</span> (&#123;</span><br><span class="line">      showWarning: !prevState.showWarning</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;WarningBanner warn=&#123;<span class="keyword">this</span>.state.showWarning&#125; /&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleToggleClick&#125;&gt;&#123;<span class="keyword">this</span>.state.showWarning ? <span class="string">"隐藏"</span> : <span class="string">"显示"</span>&#125;&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Page</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">"app"</span>));</span><br></pre></td></tr></table></figure>
<p><img src="/Web/React/prevent-component-render.gif" title="阻止组件的渲染"></p>
<blockquote>
<p>React 组件的<code>render()</code>方法返回<code>null</code>值并不会影响组件<strong>生命周期钩子函数</strong>的触发，诸如<code>componentWillUpdate()</code>和<code>componentDidUpdate()</code>依然会被正常调用。</p>
</blockquote>
<h1 id="list-和-key">List 和 Key</h1>
<p>通常情况下，在 JavaScript 当中我们会像下面代码这样循环一个数组列表。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> doubled = numbers.map(<span class="function"><span class="params">number</span> =&gt;</span> number * <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(doubled); <span class="comment">// [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure>
<p>React 当中循环一个组件列表的方式与上面非常相似，下面代码会渲染出一个从 1 至 5 编号的无序列表。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> listItems = numbers.map(<span class="function"><span class="params">number</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;number&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>&#123;listItems&#125;<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">"app"</span>));</span><br></pre></td></tr></table></figure>
<h2 id="列表组件">列表组件</h2>
<p>接下来，我们将上面例子中的列表循环封装到一个组件当中去，该组件将会接收一个<code>numbers</code>数组作为<code>props</code>。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NumberList</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> numbers = props.numbers;</span><br><span class="line">  <span class="keyword">const</span> listItems = numbers.map(<span class="function"><span class="params">number</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;number&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>&#123;listItems&#125;<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">NumberList</span> <span class="attr">numbers</span>=<span class="string">&#123;numbers&#125;</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">"app"</span>));</span><br></pre></td></tr></table></figure>
<p>但是，当你执行这段代码时，会得到这个警告信息：<code>Warning: Each child in an array or iterator should have a unique "key" prop.</code>。这里，通过添加<code>key={number.toString()}</code>可以修复该问题。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NumberList</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> numbers = props.numbers;</span><br><span class="line">  <span class="keyword">const</span> listItems = numbers.map(<span class="function"><span class="params">number</span> =&gt;</span> (</span><br><span class="line">    <span class="comment">// 列表循环中的`key`是一个特殊的字符串属性</span></span><br><span class="line">    &lt;li key=&#123;number.toString()&#125;&gt;&#123;number&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  ));</span></span><br><span class="line"><span class="regexp">  return &lt;ul&gt;&#123;listItems&#125;&lt;/u</span>l&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="列表循环的-key">列表循环的 key</h2>
<p><code>key</code>属性用来帮助 React 鉴别具体哪一项内容发生了变化，可以给列表循环当中的每个具体项一个确切的、稳定的标识。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> listItems = numbers.map(<span class="function"><span class="params">number</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;number.toString()&#125;</span>&gt;</span>&#123;number&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>);</span><br></pre></td></tr></table></figure>
<p>最佳实践是使用字符串类型的键值来作为列表循环当中每项的唯一标识，通常情况下可以使用列表的<code>id</code>值来作为<code>key</code>。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> todoItems = todos.map(<span class="function"><span class="params">todo</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;todo.id&#125;</span>&gt;</span>&#123;todo.text&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>);</span><br></pre></td></tr></table></figure>
<p>如果没有稳定的<code>id</code>值，可以考虑使用循环列表每项的索引值<code>index</code>作为<code>key</code>。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> todoItems = todos.map(<span class="function">(<span class="params">todo, index</span>) =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span>&#123;todo.text&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>);</span><br></pre></td></tr></table></figure>
<p>在列表项顺序可能发生变化的场景下，React 官方并不推荐使用索引作为<code>key</code>，因为会带来性能方面的负面影响，并引发组件状态的问题。</p>
<h2 id="key-的使用位置">key 的使用位置</h2>
<p>属性<code>key</code>只作用于数组循环上下文的内部，通常情况下是在 ES6 提供的<code>map()</code>遍历方法内。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ListItem</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里不需要指定key值</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;props.value&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NumberList</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> numbers = props.numbers;</span><br><span class="line">  <span class="keyword">const</span> listItems = numbers.map(<span class="function"><span class="params">number</span> =&gt;</span> (</span><br><span class="line">    <span class="comment">// key必须放置在数组循环的作用域范围内（即map()方法内部）</span></span><br><span class="line">    &lt;ListItem key=&#123;number.toString()&#125; value=&#123;number&#125; /&gt;</span><br><span class="line">  ));</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>&#123;listItems&#125;<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">NumberList</span> <span class="attr">numbers</span>=<span class="string">&#123;numbers&#125;</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">"app"</span>));</span><br></pre></td></tr></table></figure>
<h2 id="key-必须唯一">key 必须唯一</h2>
<p><code>key</code>值必须保持在数组循环作用域范围内的唯一，而非全局上下文范围内的唯一，因此在不同的数组循环内使用相同<code>key</code>值是被允许的。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Blog</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> sidebar = (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;props.posts.map(<span class="function"><span class="params">post</span> =&gt;</span> (</span><br><span class="line">        &lt;li key=&#123;post.id&#125;&gt; &#123;post.title&#125; &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">      ))&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/u</span>l&gt;</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">const</span> content = props.posts.map(<span class="function"><span class="params">post</span> =&gt;</span> (</span><br><span class="line">    &lt;div key=&#123;post.id&#125;&gt;</span><br><span class="line">      &lt;h3&gt;&#123;post.title&#125;&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;&#123;post.content&#125;&lt;/</span>p&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  ));</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &#123;sidebar&#125;</span></span><br><span class="line"><span class="regexp">      &lt;hr /</span>&gt;</span><br><span class="line">      &#123;content&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const posts = [&#123; id: 1, title: "你好", content: "欢迎使用React 16.6.0！" &#125;, &#123; id: 2, title: "安装方式", content: "可以通过npm和yarn安装React" &#125;];</span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Blog posts=&#123;posts&#125; /</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">"app"</span>));</span><br></pre></td></tr></table></figure>
<p><code>key</code>仅仅只是作为 React 内部的标记，并不会被渲染到组件和 DOM 当中，如果在组件内部需要使用到<code>key</code>的属性值，可以考虑也同时将其传递给组件的<code>props</code>。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> content = posts.map(<span class="function"><span class="params">post</span> =&gt;</span> (</span><br><span class="line">  <span class="comment">// post.id同时赋值给了key属性和id props。</span></span><br><span class="line">  &lt;Post key=&#123;post.id&#125; id=&#123;post.id&#125; title=&#123;post.title&#125; /&gt;</span><br><span class="line">));</span><br></pre></td></tr></table></figure>
<h2 id="嵌入-map至-jsx">嵌入 map()至 JSX</h2>
<p>JSX 允许通过花括号<code>{}</code>嵌入任意表达式，因此可以将<code>map()</code>嵌入至 JSX 行内使用。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NumberList</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> numbers = props.numbers;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;numbers.map(<span class="function"><span class="params">number</span> =&gt;</span> (</span><br><span class="line">        &lt;ListItem key=&#123;number.toString()&#125; value=&#123;number&#125; /&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>某些情况下，这样的内联风格可以得到更加整洁的代码，但如果滥用也可能会影响代码的可读性，因此需要根据实际场景权衡后再使用。但是，仍然需要注意的一点：<strong>如果<code>map()</code>循环体的嵌套过深，可以考虑将其抽象为组件</strong>。</p>
<h1 id="react-表单">React 表单</h1>
<p>HTML 表单与 React 表单的工作方式有些不同，因为 React 需要去保持一些内部状态。例如，下面的 HTML 表单将会接收一个 name 字段：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">    名称：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Submit"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>HTML 表单在用户点击提交请求之后会跳转到一个新的页面，React 当中虽然能够完成同样的工作，但是通常情况会使用一个 JavaScript 事件处理函数去操控表单提交行为，从而获取和控制用户在表单当中的输入行为，这种标准方式在 React 当中被称为<strong>受控组件</strong>。</p>
<h2 id="受控组件">受控组件</h2>
<p>HTML 表单元素<code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>、<code>&lt;select&gt;</code>会根据用户输入维护自己的状态，React 当中这些变化的状态会由组件的<code>state</code>来维护，并只能使用<code>setState()</code>进行更新。接下来，我们融合 HTML 原生表单和 React 组件<code>state</code>的行为，让 React 组件在渲染表单元素的同时，也能够控制其输入状态。这种输入状态受到 React 控制的 HTML 表单就被称为<strong>受控组件（<em>Controlled Components</em>）</strong>。</p>
<p>下面的代码，将会使用受控组件来重写本章开头的 HTML 表单示例：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputForm</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">value</span>: <span class="string">""</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.handleSubmit = <span class="keyword">this</span>.handleSubmit.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(event) &#123;</span><br><span class="line">    <span class="comment">// toUpperCase()可以让用户输入的英文总是大写</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">value</span>: event.target.value.toUpperCase() &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    alert(<span class="string">"当前提交的名称："</span> + <span class="keyword">this</span>.state.value);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          名称：</span><br><span class="line">          &lt;input type=<span class="string">"text"</span> value=&#123;<span class="keyword">this</span>.state.value&#125; onChange=&#123;<span class="keyword">this</span>.handleChange&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input type="submit" value="Submit" /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面例子中，当<code>value</code>属性设置到表单元素时，其值总是<code>this.state.value</code>的值，从而让 React 的<code>state</code>成为表单输入的内容的<strong>单一来源</strong>。伴随每次用户的输入<code>handleChange</code>都会通过<code>this.setState()</code>对<code>this.state.value</code>进行更新，从而完成 HTML 表单到 React 状态的<strong>双向绑定</strong>。</p>
<blockquote>
<p>受控组件中的每个状态变化都会关联对应的事件处理函数。</p>
</blockquote>
<h2 id="textarea-标签">textarea 标签</h2>
<p>HTML 的<code>&lt;textarea&gt;</code>标签，通过标签内部的字符串来定义其文本内容，如同下面这样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span>&gt;</span></span><br><span class="line">  Hello there, this is some text in a text area</span><br><span class="line"><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>React 当中的<code>&lt;textarea&gt;</code>依然会通过一个<code>value</code>属性来代替标签内部的字符串，其用法和上面的<code>&lt;input&gt;</code>标签相似。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextareaForm</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      value: <span class="string">"这是一句默认显示在输入域中的内容。"</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.handleSubmit = <span class="keyword">this</span>.handleSubmit.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(event) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">value</span>: event.target.value &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    alert(<span class="string">"当前提交的内容: "</span> + <span class="keyword">this</span>.state.value);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          输入内容：</span><br><span class="line">          &lt;textarea value=&#123;<span class="keyword">this</span>.state.value&#125; onChange=&#123;<span class="keyword">this</span>.handleChange&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input type="submit" value="Submit" /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="select-标签">select 标签</h2>
<p>HTML 中的<code>&lt;select&gt;</code>用来建立一个下拉列表，下面列表描述了一系列汽车品牌，并且通过<code>selected</code>属性默认选中了<strong>奔驰</strong>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"benz"</span> <span class="attr">selected</span>&gt;</span>奔驰<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"volkswagen"</span>&gt;</span>大众<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"peugeot"</span>&gt;</span>标致<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"renault"</span>&gt;</span>雷诺<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>React 中使用<code>value</code>属性代替了上面列表中<code>selected</code>默认选中的功能，因为只需要在一个位置进行更新，所以能够更加方便的使用<strong>受控组件</strong>。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FavoriteCarForm</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">value</span>: <span class="string">"coconut"</span><span class="string">'&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    this.handleChange = this.handleChange.bind(this);</span></span><br><span class="line"><span class="string">    this.handleSubmit = this.handleSubmit.bind(this);</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  handleChange(event) &#123;</span></span><br><span class="line"><span class="string">    this.setState(&#123;value: event.target.value&#125;);</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  handleSubmit(event) &#123;</span></span><br><span class="line"><span class="string">    alert("选择你最喜欢的汽车是: " + this.state.value);</span></span><br><span class="line"><span class="string">    event.preventDefault();</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  render() &#123;</span></span><br><span class="line"><span class="string">    return (</span></span><br><span class="line"><span class="string">      &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span></span><br><span class="line"><span class="string">        &lt;label&gt;</span></span><br><span class="line"><span class="string">          选择你最喜欢的汽车:</span></span><br><span class="line"><span class="string">          &lt;select value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125;&gt;</span></span><br><span class="line"><span class="string">            &lt;option value="benz"&gt;奔驰&lt;/option&gt;</span></span><br><span class="line"><span class="string">            &lt;option value="volkswagen"&gt;大众&lt;/option&gt;</span></span><br><span class="line"><span class="string">            &lt;option value="peugeot"&gt;标致&lt;/option&gt;</span></span><br><span class="line"><span class="string">            &lt;option value="renault"&gt;雷诺&lt;/option&gt;</span></span><br><span class="line"><span class="string">          &lt;/select&gt;</span></span><br><span class="line"><span class="string">        &lt;/label&gt;</span></span><br><span class="line"><span class="string">        &lt;input type="submit" value="确定" /&gt;</span></span><br><span class="line"><span class="string">      &lt;/form&gt;</span></span><br><span class="line"><span class="string">    );</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>你也可以传递一个数组到<code>value</code>属性当中，从而能够在<code>&lt;select&gt;</code>标签中选择多个属性。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;select multiple=&#123;<span class="literal">true</span>&#125; value=&#123;[<span class="string">'B'</span>, <span class="string">'C'</span>]&#125;&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总体而言，React 当中<code>&lt;input type="text"&gt;</code>、<code>&lt;textarea&gt;</code>、<code>&lt;select&gt;</code>的工作方式都非常类似，他们都能够接收一个<code>value</code>属性。</p>
</blockquote>
<h2 id="操作多个输入域">操作多个输入域</h2>
<p>当需要操作多个输入域的时候，你可以为这些输入域添加<code>name</code>属性，然后通过事件处理函数参数所提供的<code>event.target.name</code>来判断各自的行为。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reservation</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      isGoing: <span class="literal">true</span>,</span><br><span class="line">      numberOfGuests: <span class="number">2</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.handleInputChange = <span class="keyword">this</span>.handleInputChange.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleInputChange(event) &#123;</span><br><span class="line">    <span class="keyword">const</span> target = event.target;</span><br><span class="line">    <span class="keyword">const</span> value = target.type === <span class="string">"checkbox"</span> ? target.checked : target.value;</span><br><span class="line">    <span class="keyword">const</span> name = target.name;</span><br><span class="line">    <span class="comment">// 注意ES6被计算属性名称语法的使用</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      [name]: value</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          Is going:</span><br><span class="line">          &lt;input name=<span class="string">"isGoing"</span> checked=&#123;<span class="keyword">this</span>.state.isGoing&#125; onChange=&#123;<span class="keyword">this</span>.handleInputChange&#125; type=<span class="string">"checkbox"</span> /&gt;</span><br><span class="line">        &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">        &lt;br /</span>&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          <span class="built_in">Number</span> <span class="keyword">of</span> guests:</span><br><span class="line">          &lt;input name=<span class="string">"numberOfGuests"</span> value=&#123;<span class="keyword">this</span>.state.numberOfGuests&#125; onChange=&#123;<span class="keyword">this</span>.handleInputChange&#125; type=<span class="string">"number"</span> /&gt;</span><br><span class="line">        &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="设置属性值为-null">设置属性值为 null</h2>
<p>将输入域控件的<code>value</code>属性设置为<code>undefined</code>或者<code>null</code>，可以控制其编辑状态。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mountedNode = <span class="built_in">document</span>.getElementById(<span class="string">"app"</span>);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">"你好"</span> /&gt;</span></span>, mountedNode);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;null&#125;</span> /&gt;</span></span>, mountedNode);</span><br><span class="line">&#125;, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure>
<h2 id="非受控组件">非受控组件</h2>
<p>通常情况下，使用受控组件是比较冗长乏味的，因为需要编写大量事件函数去处理状态的变化，并将结果传递给 React 组件进行展示，这对于旧系统向 React 的技术迁移极不友好。这种场景下，其实可以考虑使用<strong>非受控组件</strong>（<em>uncontrolled components</em>），这是一种处理表单输入的替代技术，后面的章节将会对其进行说明。</p>
<h1 id="状态提升">状态提升</h1>
<p>当多个组件需要反映相同的状态数据时，通常建议将状态提升到这些组件的共同父级组件当中。下面，通过一个沸腾水温计算器的例子来进行说明。</p>
<p>首先，我们建立一个<code>BoilingVerdict</code>组件，该组件接收一个摄氏温度作为 props，并打印出超过 100 度的沸腾水温。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BoilingVerdict</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (props.celsius &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>水将会沸腾！<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>水不会沸腾！<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，再建立一个<code>Calculator</code>组件，用来输入温度并将其状态保持在<code>this.state.temperature</code>当中，并将这个输入值渲染到至<code>BoilingVerdict</code>组件。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">temperature</span>: <span class="string">""</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(e) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">temperature</span>: e.target.value &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> temperature = <span class="keyword">this</span>.state.temperature;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;fieldset&gt;</span><br><span class="line">        &lt;legend&gt;请输入摄氏温度：&lt;<span class="regexp">/legend&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input value=&#123;temperature&#125; onChange=&#123;this.handleChange&#125; /</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;BoilingVerdict celsius=&#123;<span class="built_in">parseFloat</span>(temperature)&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/fieldset&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="添加第-2-个输入域">添加第 2 个输入域</h2>
<p>接下来，需要再添加一个输入域来输入华氏温度，并保持它们的状态同步。</p>
<p>首先，从<code>Calculator</code>组件抽象一个<code>TemperatureInput</code>组件，并增加一个名称为<code>scale</code>的 props（<em>值为 c 或者 f</em>），</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> scaleNames = &#123;</span><br><span class="line">  c: <span class="string">"摄氏"</span>,</span><br><span class="line">  f: <span class="string">"华氏"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TemperatureInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">temperature</span>: <span class="string">""</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(e) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">temperature</span>: e.target.value &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> temperature = <span class="keyword">this</span>.state.temperature;</span><br><span class="line">    <span class="keyword">const</span> scale = <span class="keyword">this</span>.props.scale;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;fieldset&gt;</span><br><span class="line">        &lt;legend&gt;</span><br><span class="line">          请输入</span><br><span class="line">          &#123;scaleNames[scale]&#125;</span><br><span class="line">          温度：</span><br><span class="line">        &lt;<span class="regexp">/legend&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input value=&#123;temperature&#125; onChange=&#123;this.handleChange&#125; /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/fieldset&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>然后，修改一下<code>Calculator</code>组件，使其能够分别渲染<code>scale</code>为<code>c</code>或<code>f</code>的两个<code>TemperatureInput</code>组件。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;TemperatureInput scale=<span class="string">"c"</span> /&gt;</span><br><span class="line">        &lt;TemperatureInput scale=<span class="string">"f"</span> /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>进行到这一步，我们已经拥有两个输入域，但是输入其中的一个，并不会导致另一个同步更新，这并不符合本章节开头的需求。而且由于温度状态位于<code>TemperatureInput</code>组件内部，<code>Calculator</code>组件无法直接对其进行显示。</p>
<h2 id="编写转换函数">编写转换函数</h2>
<p>我们的例子中，还需要两个对摄氏/华氏温度进行相互转换的函数。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toCelsius</span>(<span class="params">fahrenheit</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ((fahrenheit - <span class="number">32</span>) * <span class="number">5</span>) / <span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toFahrenheit</span>(<span class="params">celsius</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (celsius * <span class="number">9</span>) / <span class="number">5</span> + <span class="number">32</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以及一个对输入温度进行合法性校验的函数，不合法时返回空字符串，合法则返回值精确到小数点第 3 位。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tryConvert</span>(<span class="params">temperature, convert</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> input = <span class="built_in">parseFloat</span>(temperature);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Number</span>.isNaN(input)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> output = convert(input);</span><br><span class="line">  <span class="keyword">const</span> rounded = <span class="built_in">Math</span>.round(output * <span class="number">1000</span>) / <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">return</span> rounded.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tryConvert(<span class="string">"abc"</span>, toCelsius); <span class="comment">// 返回空字符串</span></span><br><span class="line">tryConvert(<span class="string">"10.22"</span>, toFahrenheit); <span class="comment">// 返回'50.396'</span></span><br></pre></td></tr></table></figure>
<p>根据上面改造之后，<code>TemperatureInput</code>组件已经可以独立的保持输入值在各自的<code>state</code>当中。但是我们希望保持两个输入域的同步，比如输入华氏温度的时候，摄氏温度会自动展示被转换后的温度值。</p>
<h2 id="完整-demo">完整 Demo</h2>
<p>React 当中，多个组件之间<code>state</code>的共享，需要将这些<code>state</code>放置到共同的父级组件，这种方式被称为<strong>state 状态提升</strong>。这个例子中，我们需要将<code>TemperatureInput</code>组件里需要共享的<code>state</code>移动到<code>Calculator</code>组件内，然后通过<code>TemperatureInput</code>组件上的<code>props</code>属性向下分发这些共享数据，最终实现两个<code>TemperatureInput</code>组件内的输入值的同步更新。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TemperatureInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(e) &#123;</span><br><span class="line">    <span class="comment">// 调用父组件通过props传入进来的事件处理函数，从而实现在子组件更新父组件的state</span></span><br><span class="line">    <span class="keyword">this</span>.props.onTemperatureChange(e.target.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> temperature = <span class="keyword">this</span>.props.temperature;</span><br><span class="line">    <span class="keyword">const</span> scale = <span class="keyword">this</span>.props.scale;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;fieldset&gt;</span><br><span class="line">        &lt;legend&gt;Enter temperature <span class="keyword">in</span> &#123;scaleNames[scale]&#125;:&lt;<span class="regexp">/legend&gt;</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ 当输入域的值发生变化时，触发本组件内的handleChange事件处理函数</span></span><br><span class="line"><span class="regexp">        &lt;input value=&#123;temperature&#125; onChange=&#123;this.handleChange&#125; /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/fieldset&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleCelsiusChange = <span class="keyword">this</span>.handleCelsiusChange.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.handleFahrenheitChange = <span class="keyword">this</span>.handleFahrenheitChange.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">temperature</span>: <span class="string">""</span>, <span class="attr">scale</span>: <span class="string">"c"</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过props传递给子组件的事件处理函数，让子组件具备修改父组件state的能力</span></span><br><span class="line">  handleCelsiusChange(temperature) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">scale</span>: <span class="string">"c"</span>, temperature &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  handleFahrenheitChange(temperature) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">scale</span>: <span class="string">"f"</span>, temperature &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> scale = <span class="keyword">this</span>.state.scale; <span class="comment">// 温度单位</span></span><br><span class="line">    <span class="keyword">const</span> temperature = <span class="keyword">this</span>.state.temperature; <span class="comment">// 温度值</span></span><br><span class="line">    <span class="keyword">const</span> celsius = scale === <span class="string">"f"</span> ? tryConvert(temperature, toCelsius) : temperature; <span class="comment">// 摄氏温度</span></span><br><span class="line">    <span class="keyword">const</span> fahrenheit = scale === <span class="string">"c"</span> ? tryConvert(temperature, toFahrenheit) : temperature; <span class="comment">// 华氏温度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;TemperatureInput scale=<span class="string">"c"</span> temperature=&#123;celsius&#125; onTemperatureChange=&#123;<span class="keyword">this</span>.handleCelsiusChange&#125; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TemperatureInput scale=<span class="string">"f"</span> temperature=&#123;fahrenheit&#125; onTemperatureChange=&#123;<span class="keyword">this</span>.handleFahrenheitChange&#125; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;BoilingVerdict celsius=&#123;<span class="built_in">parseFloat</span>(celsius)&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p><img src="/Web/React/lifting-state-up.gif" title="state状态提升"></p>
<p>通常情况下，更新<code>state</code>将会触发组件的重绘，如果多个组件需要共享同一个<code>state</code>，可以考虑将这些<code>state</code>抬升到其共同的父组件当中，然后通过<strong>至上而下</strong>的数据流来完成<code>state</code>的同步更新。</p>
<p>相比于 Angular、Vue2 原生提供的双向绑定机制，React 当中<code>state</code>的<strong>状态提升</strong>涉及到书写更多的样板代码，但优点在于更加容易探测到一些潜在的 bug，以及在状态变化过程中切入一些处理逻辑，比如上面例子中体现的数字精度控制和输入数据类型校验。</p>
<blockquote>
<p><em>事实上，Vue2 的响应式更新机制是属于组件级别的，而且已经取消了组件内部的<code>state</code>属性，有效避免组件间<code>state</code>互相污染的问题，因此 FB 认为这是优点的说法比较牵强，否则也不会在 Redux 之后有 MobX 的出现。</em></p>
</blockquote>
<h1 id="组合与继承">组合与继承</h1>
<p>React 组件拥有强大的组合模型，我们推荐通过组合而非继承来完成组件的复用。</p>
<h2 id="内容包含">内容包含</h2>
<p>默认情况下，许多组件并不了解其子元素的情况（<em>比如侧边栏和对话框组件</em>），这样的情况推荐使用<code>props</code>的<code>children</code>属性<strong>将组件内部嵌套的元素内容直接渲染至组件的输出当中</strong>，例如下面就定义了一个使用该属性的组件：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Border</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;</span>"<span class="attr">border-</span>" + <span class="attr">props.color</span>&#125;&gt;</span>&#123;props.children&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，使用 JSX 语法向这个组件内放入任意内容。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dialog</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Border color=<span class="string">"blue"</span>&gt;</span><br><span class="line">      &lt;h1 className=<span class="string">"title"</span>&gt;标题&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p className="message"&gt;内容&lt;/</span>p&gt;</span><br><span class="line">    &lt;<span class="regexp">/Border&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>最后添加一个额外的样式，为组件的渲染内容呈现一个蓝色的边框。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.blue-border</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">10px</span> solid blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>&lt;border /&gt;</code>组件内的 JSX 元素内容最终会被渲染到组件内<code>{props.children}</code>所在的位置，最后的结果看起来是下面这样的：</p>
<p><img src="/Web/React/composition-inheritance-1.png" title="渲染结果"></p>
<p>React 当中<code>{props.children}</code>的作用类似于 Vue2 当中的<code>&lt;slot /&gt;</code>元素，本质都是为了将嵌入组件的内容，在组件渲染时以合适的方式进行展示。当在需要嵌入多段内容的情况下，Vue2 通过具名插槽<code>&lt;slot name=""&gt;</code>来解决这个问题，而 React 解决该问题的方式与 Vue2 类似。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Box</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"box"</span>&gt;</span><br><span class="line">      &lt;div className=<span class="string">"left"</span>&gt; &#123;props.left&#125; &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div className="right"&gt; &#123;props.right&#125; &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function App() &#123;</span></span><br><span class="line"><span class="regexp">  return &lt;Box left=&#123;&lt;Contacts /</span>&gt;&#125; right=&#123;&lt;Chat /&gt;&#125; /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">70%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>React 组件本质是一个对象</strong>，因此可以将其作为<code>props</code>的属性值进行传递，上面代码的执行结果如下：</p>
<p><img src="/Web/React/composition-inheritance-2.png" title="渲染结果"></p>
<h2 id="特殊化">特殊化</h2>
<p>某些场景下，需要对某个组件进行特殊化处理，比如将<code>Dialog</code>组件具象成为一个<code>WelcomeDialog</code>组件，通常情况大家会首先想到使用继承，但是 React 当中依然可以通过使用组合解决这个问题。即在<code>WelcomeDialog</code>组件内渲染<code>Dialog</code>组件，并通过<code>props</code>属性配置<code>Dialog</code>的行为。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dialog</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Border color=<span class="string">"blue"</span>&gt;</span><br><span class="line">      &lt;h1 className=<span class="string">"title"</span>&gt; &#123;props.title&#125; &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p className="message"&gt; &#123;props.message&#125; &lt;/</span>p&gt;</span><br><span class="line">    &lt;<span class="regexp">/Border&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function WelcomeDialog() &#123;</span></span><br><span class="line"><span class="regexp">  return &lt;Dialog title="欢迎" message="感谢访问！" /</span>&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Facebook 开发团队内部已经使用 React 实现了数以千计的组件，但是并未出现需要推荐使用继承结构的用例。通过搭配使用<code>props</code>与<code>组合</code>，可以灵活的定制各类组件。另外需要特别注意的是，React 组件可以接受任意类型的<code>props</code>，包括原生的对象或者回调函数，甚至是一个 React 组件对象本身。</p>
<blockquote>
<p>而对于非 UI 相关的功能性复用，建议分离到单独的 JavaScript 模块当中，以功能函数、对象或类的方式进行实现。</p>
</blockquote>
<h1 id="react-编程思想">React 编程思想</h1>
<p>React 特别适用于大规模的 JavaScript 应用程序，并且已经在 Facebook 和 Instagram 相关产品上进行了实践。React 最优秀的特性来自于其提出的组件化思想，即将 DOM 页面分片断进行开发，通过 DOM 片断进行业务逻辑和功能层面的复用。组件的拆分可以遵从设计模式中的单一职责原则（<em>single responsibility principle</em>），即一个组件理想状态下只完成一件事情，下面是 React 官网提供的一个商品表格的示例：</p>
<p><img src="/Web/React/thinking-in-react-components.png"></p>
<h2 id="组件嵌套结构">组件嵌套结构</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FilterableProductTable</span><br><span class="line">└── SearchBar</span><br><span class="line">└── ProductTable</span><br><span class="line">   └── ProductCategoryRow</span><br><span class="line">   └── ProductRow</span><br></pre></td></tr></table></figure>
<h2 id="组件功能说明">组件功能说明</h2>
<p><code>FilterableProductTable</code>：<strong>橙色</strong>，包含所有组件。 <code>SearchBar</code>：<strong>蓝色</strong>，接收用户输入。 <code>ProductTable</code>：<strong>绿色</strong>，基于用户输入显示和过滤数据集合。 <code>ProductCategoryRow</code>：<strong>青色</strong>，显示分类的标题。 <code>ProductRow</code>：<strong>红色</strong>，显示每款商品。</p>
<h2 id="完整示例代码">完整示例代码</h2>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ProductCategoryRow */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductCategoryRow</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> category = <span class="keyword">this</span>.props.category;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;tr&gt;</span><br><span class="line">        &lt;th colSpan=<span class="string">"2"</span>&gt;&#123;category&#125;&lt;<span class="regexp">/th&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>tr&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ProductRow */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductRow</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> product = <span class="keyword">this</span>.props.product;</span><br><span class="line">    <span class="keyword">const</span> name = product.stocked ? product.name : <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color:</span> "<span class="attr">red</span>" &#125;&#125;&gt;</span> &#123;product.name&#125; <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;&#123;name&#125;&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">        &lt;td&gt;&#123;product.price&#125;&lt;/</span>td&gt;</span><br><span class="line">      &lt;<span class="regexp">/tr&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span>* ProductTable *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">class ProductTable extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    const filterText = this.props.filterText;</span></span><br><span class="line"><span class="regexp">    const inStockOnly = this.props.inStockOnly;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    const rows = [];</span></span><br><span class="line"><span class="regexp">    let lastCategory = null;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    this.props.products.forEach(product =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      if (product.name.indexOf(filterText) === -1) &#123;</span></span><br><span class="line"><span class="regexp">        return;</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">      if (inStockOnly &amp;&amp; !product.stocked) &#123;</span></span><br><span class="line"><span class="regexp">        return;</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">      if (product.category !== lastCategory) &#123;</span></span><br><span class="line"><span class="regexp">        rows.push(&lt;ProductCategoryRow category=&#123;product.category&#125; key=&#123;product.category&#125; /</span>&gt;);</span><br><span class="line">      &#125;</span><br><span class="line">      rows.push(<span class="xml"><span class="tag">&lt;<span class="name">ProductRow</span> <span class="attr">product</span>=<span class="string">&#123;product&#125;</span> <span class="attr">key</span>=<span class="string">&#123;product.name&#125;</span> /&gt;</span></span>);</span><br><span class="line">      lastCategory = product.category;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;table&gt;</span><br><span class="line">        &lt;thead&gt;</span><br><span class="line">          &lt;tr&gt;</span><br><span class="line">            &lt;th&gt;Name&lt;<span class="regexp">/th&gt;</span></span><br><span class="line"><span class="regexp">            &lt;th&gt;Price&lt;/</span>th&gt;</span><br><span class="line">          &lt;<span class="regexp">/tr&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>thead&gt;</span><br><span class="line">        &lt;tbody&gt;&#123;rows&#125;&lt;<span class="regexp">/tbody&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>table&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* SearchBar */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SearchBar</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleFilterTextChange = <span class="keyword">this</span>.handleFilterTextChange.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.handleInStockChange = <span class="keyword">this</span>.handleInStockChange.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleFilterTextChange(e) &#123;</span><br><span class="line">    <span class="keyword">this</span>.props.onFilterTextChange(e.target.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleInStockChange(e) &#123;</span><br><span class="line">    <span class="keyword">this</span>.props.onInStockChange(e.target.checked);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form&gt;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> placeholder=<span class="string">"Search..."</span> value=&#123;<span class="keyword">this</span>.props.filterText&#125; onChange=&#123;<span class="keyword">this</span>.handleFilterTextChange&#125; /&gt;</span><br><span class="line">        &lt;p&gt;</span><br><span class="line">          &lt;input type=<span class="string">"checkbox"</span> checked=&#123;<span class="keyword">this</span>.props.inStockOnly&#125; onChange=&#123;<span class="keyword">this</span>.handleInStockChange&#125; /&gt; Only show products <span class="keyword">in</span> stock</span><br><span class="line">        &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* FilterableProductTable */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilterableProductTable</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      filterText: <span class="string">""</span>,</span><br><span class="line">      inStockOnly: <span class="literal">false</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.handleFilterTextChange = <span class="keyword">this</span>.handleFilterTextChange.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.handleInStockChange = <span class="keyword">this</span>.handleInStockChange.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleFilterTextChange(filterText) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      filterText: filterText</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleInStockChange(inStockOnly) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      inStockOnly: inStockOnly</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;SearchBar filterText=&#123;<span class="keyword">this</span>.state.filterText&#125; inStockOnly=&#123;<span class="keyword">this</span>.state.inStockOnly&#125; onFilterTextChange=&#123;<span class="keyword">this</span>.handleFilterTextChange&#125; onInStockChange=&#123;<span class="keyword">this</span>.handleInStockChange&#125; /&gt;</span><br><span class="line">        &lt;ProductTable products=&#123;<span class="keyword">this</span>.props.products&#125; filterText=&#123;<span class="keyword">this</span>.state.filterText&#125; inStockOnly=&#123;<span class="keyword">this</span>.state.inStockOnly&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span>* <span class="built_in">JSON</span> API *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">const PRODUCTS = [&#123; category: "Sporting Goods", price: "$49.99", stocked: true, name: "Football" &#125;, &#123; category: "Sporting Goods", price: "$9.99", stocked: true, name: "Baseball" &#125;, &#123; category: "Sporting Goods", price: "$29.99", stocked: false, name: "Basketball" &#125;, &#123; category: "Electronics", price: "$99.99", stocked: true, name: "iPod Touch" &#125;, &#123; category: "Electronics", price: "$399.99", stocked: false, name: "iPhone 5" &#125;, &#123; category: "Electronics", price: "$199.99", stocked: true, name: "Nexus 7" &#125;];</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;FilterableProductTable products=&#123;PRODUCTS&#125; /</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">"app"</span>));</span><br></pre></td></tr></table></figure>
<p><img src="/Web/React/thinking-in-react-mock.gif" title="代码运行结果"></p>
<blockquote>
<p>React 拥有 2 种不同类型的<strong>模型数据</strong>（<em>Model</em>）：<code>props</code>和<code>state</code>。</p>
</blockquote>
<h1 id="深入-jsx">深入 JSX</h1>
<p>本质上而言，JSX 其实是<code>React.createElement(component, props, ...children)</code>函数的语法糖。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JSX</span></span><br><span class="line">&lt;MyButton color=<span class="string">"blue"</span> shadowSize=&#123;<span class="number">2</span>&#125;&gt;</span><br><span class="line">  点击我</span><br><span class="line">&lt;<span class="regexp">/MyButton&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 等效的React.createElement()</span></span><br><span class="line"><span class="regexp">React.createElement(</span></span><br><span class="line"><span class="regexp">  MyButton,</span></span><br><span class="line"><span class="regexp">  &#123; color: 'blue', shadowSize: 2 &#125;,</span></span><br><span class="line"><span class="regexp">  '点击我'</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用自关闭标签的JSX</span></span><br><span class="line">&lt;div className=<span class="string">"sidebar"</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面JSX会被编译为如下代码</span></span><br><span class="line">React.createElement(</span><br><span class="line">  <span class="string">'div'</span>,</span><br><span class="line">  &#123; <span class="attr">className</span>: <span class="string">'sidebar'</span> &#125;,</span><br><span class="line">  <span class="literal">null</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="指定-react-的元素类型">指定 React 的元素类型</h2>
<p>React 当中，可以将组件赋值给一个变量或者常量，如果代码中使用名为<code>&lt;Test&gt;</code>的组件，则组件对应的<code>Test</code>变量必须位于当前组件的作用域内。此外，定义组件时必须显式引入<code>React</code>库，即使当前组件没有直接对其进行引用。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>; <span class="comment">// 这样的引用是必须的</span></span><br><span class="line"><span class="keyword">import</span> CustomButton <span class="keyword">from</span> <span class="string">"./CustomButton"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">WarningButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">CustomButton</span> <span class="attr">color</span>=<span class="string">"red"</span> /&gt;</span></span>;</span><br><span class="line">  <span class="comment">// return React.createElement(CustomButton, &#123;color: 'red'&#125;, null);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当一个模块需要<code>export</code>多个 React 组件时，可以将这些组件定义为一个对象的属性之后导出，然后 JSX 内使用时通过<code>.</code>操作符进行引用。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyComponents = &#123;</span><br><span class="line">  DatePicker: <span class="function"><span class="keyword">function</span> <span class="title">DatePicker</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Imagine a &#123;props.color&#125; datepicker here.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BlueDatePicker</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 通过MyComponents.DatePicker引用上面对象MyComponents内定义的DatePicker组件</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">MyComponents.DatePicker</span> <span class="attr">color</span>=<span class="string">"blue"</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>用户自定义组件的名称首字母必须大写</strong>，以便于在字面上与原生的<code>&lt;v&gt;</code>或<code>&lt;span&gt;</code>进行有效区分。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确！自定义组件首字母大写。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hello</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 正确！原生HTML标签是小写的。</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello &#123;props.toWhat&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HelloWorld</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 正确! React能够正确识别首字母大写的自定义组件。</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Hello</span> <span class="attr">toWhat</span>=<span class="string">"World"</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不能以 React 元素的方式使用 JavaScript 表达式，例如下面的代码：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; PhotoStory, VideoStory &#125; <span class="keyword">from</span> <span class="string">'./stories'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> components = &#123;</span><br><span class="line">  photo: PhotoStory,</span><br><span class="line">  video: VideoStory</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Story</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 错误，JSX类型不能是一个表达式。</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">components[props.storyType]</span> <span class="attr">story</span>=<span class="string">&#123;props.story&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决上面问题，需要将表达式赋值给一个首字母大写的变量，参见下面的代码：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; PhotoStory, VideoStory &#125; <span class="keyword">from</span> <span class="string">"./stories"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> components = &#123;</span><br><span class="line">  photo: PhotoStory,</span><br><span class="line">  video: VideoStory</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Story</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 正确！JSX类型可以是一个首字母大写的变量。</span></span><br><span class="line">  <span class="keyword">const</span> SpecificStory = components[props.storyType];</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">SpecificStory</span> <span class="attr">story</span>=<span class="string">&#123;props.story&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="jsx-中的-props">JSX 中的 props</h2>
<h3 id="以-javascript-表达式的方式">以 JavaScript 表达式的方式</h3>
<p>开发人员可以通过<code>{}</code>传递任意 JavaScript 表达式到<code>prpps</code>。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyComponent组件的props.foo的值为10</span></span><br><span class="line">&lt;MyComponent foo=&#123;<span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">4</span>&#125; /&gt;</span><br></pre></td></tr></table></figure>
<p><code>if</code>和<code>for</code>语句并不属于 JavaScript 中的表达式，因此可以直接用于 JSX。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">contextSwitching</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name;</span><br><span class="line">  <span class="keyword">if</span> (props.context == <span class="string">"internet"</span>) &#123;</span><br><span class="line">    name = <span class="xml"><span class="tag">&lt;<span class="name">i</span>&gt;</span>Uinika<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (props.context === <span class="string">"reallife"</span>) &#123;</span><br><span class="line">    name = <span class="xml"><span class="tag">&lt;<span class="name">i</span>&gt;</span>Hank<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">      在&#123;props.context&#125;</span><br><span class="line">      里我叫</span><br><span class="line">      &#123;name&#125;</span><br><span class="line">    &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串字面量">字符串字面量</h3>
<p>可以向 props 传递字符串字面量，下面的两个 JSX 是等效的。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent message=<span class="string">"Hello React16！"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;MyComponent message=&#123;<span class="string">'Hello React16！'</span>&#125; /&gt;</span><br></pre></td></tr></table></figure>
<p>传递的字符串变量可以是非 HTML 转义的，因此下面的两个 JSX 表达式仍然是等效的。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent message=<span class="string">"&amp;lt;5"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;MyComponent message=&#123;<span class="string">'&lt;5'</span>&#125; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="props-默认为-true">props 默认为 true</h3>
<p>如果没有向组件的 props 传递值（<em>声明 props 但并未进行赋值</em>），则该<strong>props 的值默认为<code>true</code></strong>，下面的两行代码因此是等效的：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyTextBox autocomplete /&gt;</span><br><span class="line"></span><br><span class="line">&lt;MyTextBox autocomplete=&#123;<span class="literal">true</span>&#125; /&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通常情况并不建议缺省 props 的值，因为这样容易与 ES6 的对象快捷声明特性，语法上发生混淆。</p>
</blockquote>
<h3 id="props-对象扩展运算">props 对象扩展运算</h3>
<p>如果你的<code>props</code>是一个<strong>对象</strong>，可以考虑使用 ES6 的<strong>对象扩展运算符</strong><code>...</code>，将所有的<code>props</code>一次性传入组件。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Component1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Hello</span> <span class="attr">firstName</span>=<span class="string">"Hank"</span> <span class="attr">lastName</span>=<span class="string">"Zen"</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Component2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> props = &#123; <span class="attr">firstName</span>: <span class="string">"Hank"</span>, <span class="attr">lastName</span>: <span class="string">"Zen"</span> &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Hello</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你还可以让组件使用特定的<code>props</code>，然后通过对象扩展运算符传递其它所有<code>props</code>。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Button = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; kind, ...all &#125; = props;</span><br><span class="line">  <span class="keyword">const</span> className = kind === <span class="string">"primary"</span> ? <span class="string">"btn-primary"</span> : <span class="string">"btn-default"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&#123;className&#125;</span> &#123;<span class="attr">...all</span>&#125; /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Button kind=<span class="string">"primary"</span> onClick=&#123;() =&gt; <span class="built_in">console</span>.log(<span class="string">"被点击了!"</span>)&#125;&gt;</span><br><span class="line">        Hello React <span class="number">16.2</span>！</span><br><span class="line">      &lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面例子中的<code>{ kind, ...all }</code>只会获取 props 中的<code>kind</code>属性，然后将<code>props</code>中其它属性全部赋值给<code>...all</code>，</p>
<blockquote>
<p>对象扩展运算符是非常有用的工具，但是容易将一些不必要的<code>props</code>传递给组件，因此建议酌情根据需要进行使用。</p>
</blockquote>
<h2 id="jsx-的-children">JSX 的 children</h2>
<p>JSX 表达式开始、结束标签内的内容会以特殊的 props 形式传递：<code>props.children</code>，React 有几种不同的方式去传递这些<code>children</code>。</p>
<h3 id="字符串字面量-1">字符串字面量</h3>
<p>在 JSX 开始和结束标签内直接书写字符串，<code>props.children</code>的值就是这段字符串内容。字符串的内容可以是非 HTML 转义的，因此编写 JSX 就像编写 HTML 一样。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyComponent组件的props.children就是"Hello React 16!"</span></span><br><span class="line">&lt;MyComponent&gt;Hello React <span class="number">16</span>!&lt;<span class="regexp">/MyComponent&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ JSX内可以直接书写HTML字符实体</span></span><br><span class="line"><span class="regexp">&lt;div&gt;Hank &amp;amp; Github.&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure>
<p>JSX 会自动移除开始和结束行的空格，标签附近的新的行也会被同时移除，标签内部内容当中出现的空格会被缩进为一个空格，所以下面 JSX 代码的渲染结果都相同。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Hello React <span class="number">16</span>!&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;p&gt;</span></span><br><span class="line"><span class="regexp">  Hello React 16!</span></span><br><span class="line"><span class="regexp">&lt;/</span>p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;</span><br><span class="line">  Hello</span><br><span class="line">  React <span class="number">16</span>!</span><br><span class="line">&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;p&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  Hello React 16!</span></span><br><span class="line"><span class="regexp">&lt;/</span>p&gt;</span><br></pre></td></tr></table></figure>
<h3 id="嵌套的-jsx">嵌套的 JSX</h3>
<p>JSX 开始结束标签内依然可以使用其它标签作为子元素，从而能够以嵌套的使用各类 React 组件和 HTML 元素。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyContainer&gt;</span><br><span class="line">  &lt;MyFirstComponent /&gt;</span><br><span class="line">  &lt;MySecondComponent /&gt;</span><br><span class="line">&lt;<span class="regexp">/MyContainer&gt;</span></span><br></pre></td></tr></table></figure>
<p>React16 带来的一个重要新特性之一是：<strong>组件可以直接返回一个数组元素</strong>。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="comment">// 毋需将多个列表元素包裹到一个元素当中返回，这样可以防止破坏HTML页面语义化</span></span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    <span class="comment">// 一定要记得为每个列表元素添加唯一的key</span></span><br><span class="line">    &lt;li key=<span class="string">"A"</span>&gt;First item&lt;<span class="regexp">/li&gt;,</span></span><br><span class="line"><span class="regexp">    &lt;li key="B"&gt;Second item&lt;/</span>li&gt;,</span><br><span class="line">    &lt;li key=<span class="string">"C"</span>&gt;Third item&lt;<span class="regexp">/li&gt;,</span></span><br><span class="line"><span class="regexp">  ];</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="javascript-表达式作为子元素">JavaScript 表达式作为子元素</h3>
<p>React 可以通过<code>{}</code>运算符使用任意 JavaScript 表达式作为 JSX 子元素，例如下面两个表达式就是等效的：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent&gt;foo&lt;<span class="regexp">/MyComponent&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;MyComponent&gt;&#123;'foo'&#125;&lt;/</span>MyComponent&gt;</span><br></pre></td></tr></table></figure>
<p>这在渲染任意长度的 JSX 表达式列表时非常有用，请参见下面的代码：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Item</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;props.message&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">List</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> todos = [<span class="string">'工作'</span>, <span class="string">'生活'</span>, <span class="string">'运动'</span>，<span class="string">'早睡早起'</span>];</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;todos.map(<span class="function">(<span class="params">message</span>) =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">Item</span> <span class="attr">key</span>=<span class="string">&#123;message&#125;</span> <span class="attr">message</span>=<span class="string">&#123;message&#125;</span> /&gt;</span></span>)&#125;</span><br><span class="line">    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>JavaScript 表达式可以与其它类型子元素混用，这在为模板绑定数据的时候非常有用。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hello</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello &#123;props.addressee&#125;!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数作为子元素">函数作为子元素</h3>
<p>与<code>props</code>属性一样，<code>props.children</code>可以传递任意类型的数据，组件会在渲染前解析<code>props.children</code>中的内容。例如，可以通过<code>props.children</code>向一个自定义组件传递回调函数。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Calls the children callback numTimes to produce a repeated component</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Repeat</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> items = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; props.numTimes; i++) &#123;</span><br><span class="line">    items.push(props.children(i));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;items&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ListOfTenThings</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Repeat</span> <span class="attr">numTimes</span>=<span class="string">&#123;10&#125;</span>&gt;</span>&#123;index =&gt; <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span>This is item &#123;index&#125; in the list<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;<span class="tag">&lt;/<span class="name">Repeat</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面的方法日常开发中并不常用，但是在一些需要对 JSX 功能进行扩展的的场景下还是非常有用的。</p>
</blockquote>
<h2 id="booleannullundefined-会被忽略">boolean、null、undefined 会被忽略</h2>
<p><code>boolean</code>、<code>null</code>、<code>undefined</code>都是合法的子元素，这些类型的内容不会被渲染，因此下面例子中的 JSX 会渲染相同的结果：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div /&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;div&gt;&#123;false&#125;&lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;&#123;<span class="literal">null</span>&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;div&gt;&#123;undefined&#125;&lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;&#123;<span class="literal">true</span>&#125;&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>
<p>这对于条件运算是非常有用的，下面的 JSX 当<code>showHeader</code>为<code>true</code>时只会渲染出一个<code>&lt;Header /&gt;</code>。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;showHeader &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span>&#125;</span><br><span class="line">  &lt;Content /&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>
<p>值得注意的是，数字<strong>0</strong>（<em>布尔运算中通常被判断为假值</em>）会被 React 原样渲染，例如当下面代码中的<code>props.messages</code>是一个空数组的时候，数值<code>0</code>将会被展示到页面上。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&#123;props.messages.length &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">MessageList</span> <span class="attr">messages</span>=<span class="string">&#123;props.messages&#125;</span> /&gt;</span></span>&#125;&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>
<p>解决这个问题，需要显式的使用布尔运算符<code>&amp;&amp;</code>，将上面的代码修改成下面这样：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&#123;props.messages.length &gt; <span class="number">0</span> &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">MessageList</span> <span class="attr">messages</span>=<span class="string">&#123;props.messages&#125;</span> /&gt;</span></span>&#125;&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>
<p>与此相反，如果需要将<code>false</code>、<code>true</code>、<code>null</code>、<code>undefined</code>之类的值展示到页面，需要首先将这些值转换为字符串。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;My JavaScript variable is &#123;<span class="built_in">String</span>(myVariable)&#125;.&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="proptypes-类型检查">PropTypes 类型检查</h1>
<p>从伴随应用程序规模的增长，需要进行大量的类型检查工作，因此 React 内建了组件<code>props</code>类型检查机制。但是从 React v15.5 开始，<code>React.PropTypes</code>被迁移到单独的<code>prop-types</code>包。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">"prop-types"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.text&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Component.propTypes = &#123;</span><br><span class="line">  text: PropTypes.string.isRequired</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>PropTypes</code>对象上暴露了一系列校验器，用来确保当前组件接收的数据是合法的，例如上面代码中的<code>PropTypes.string.isRequired</code>，当<code>props</code>的值非法时，浏览器控制台将会接收到警告信息。</p>
<blockquote>
<p>出于性能方面的考量，PropTypes 类型检查只工作在<strong>开发模式</strong>下。</p>
</blockquote>
<h2 id="proptypes">PropTypes</h2>
<p>下面是 PropTypes 上各类校验器的使用实例：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">"prop-types"</span>;</span><br><span class="line"></span><br><span class="line">MyComponent.propTypes = &#123;</span><br><span class="line">  <span class="comment">// 可以将PropTypes声明为JS数据类型。</span></span><br><span class="line">  optionalArray: PropTypes.array,</span><br><span class="line">  optionalBool: PropTypes.bool,</span><br><span class="line">  optionalFunc: PropTypes.func,</span><br><span class="line">  optionalNumber: PropTypes.number,</span><br><span class="line">  optionalObject: PropTypes.object,</span><br><span class="line">  optionalString: PropTypes.string,</span><br><span class="line">  optionalSymbol: PropTypes.symbol,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 所有能够被React渲染的内容，例如：numbers, strings, elements, array以及fragment。</span></span><br><span class="line">  optionalNode: PropTypes.node,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一个React元素。</span></span><br><span class="line">  optionalElement: PropTypes.element,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过instanceof操作符将prop声明为一个类的实例。</span></span><br><span class="line">  optionalMessage: PropTypes.instanceOf(Message),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 确保props是指定枚举类型中的值。</span></span><br><span class="line">  optionalEnum: PropTypes.oneOf([<span class="string">"News"</span>, <span class="string">"Photos"</span>]),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否属于指定类型之一。</span></span><br><span class="line">  optionalUnion: PropTypes.oneOfType([PropTypes.string, PropTypes.number, PropTypes.instanceOf(Message)]),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拥有指定数据类型的数组。</span></span><br><span class="line">  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 具有特定类型属性值的对象。</span></span><br><span class="line">  optionalObjectOf: PropTypes.objectOf(PropTypes.number),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对拥有特定属性结构的对象进行校验。</span></span><br><span class="line">  optionalObjectWithShape: PropTypes.shape(&#123;</span><br><span class="line">    color: PropTypes.string,</span><br><span class="line">    fontSize: PropTypes.number</span><br><span class="line">  &#125;),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可以链式调用isRequired，指定props缺省时会打印警告信息。</span></span><br><span class="line">  requiredFunc: PropTypes.func.isRequired,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 任意数据类型</span></span><br><span class="line">  requiredAny: PropTypes.any.isRequired,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 自定义的校验器，校验失败返回一个Error对象（不要直接console.warn或者throw）。</span></span><br><span class="line">  customProp: <span class="function"><span class="keyword">function</span>(<span class="params">props, propName, componentName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="regexp">/matchme/</span>.test(props[propName])) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"不合法的prop `"</span> + propName + <span class="string">"` 被应用到"</span> + <span class="string">" `"</span> + componentName + <span class="string">"`. 校验失败."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在arrayOf和objectOf上指定自定义的校验器，校验失败同样返回一个Error对象，校验器会在array或object的每个属性上得到调用，校验器第1个参数是array或object本身，第2个参数是当前项的key值。</span></span><br><span class="line">  customArrayProp: PropTypes.arrayOf(<span class="function"><span class="keyword">function</span>(<span class="params">propValue, key, componentName, location, propFullName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="regexp">/matchme/</span>.test(propValue[key])) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"不合法的prop `"</span> + propFullName + <span class="string">"` 被应用到"</span> + <span class="string">" `"</span> + componentName + <span class="string">"`. 校验失败."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="需要单一的子元素">需要单一的子元素</h2>
<p>通过<code>PropTypes.element</code>可以指定当前组件只能拥有一个单一的子元素，否则将会出现告警信息。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">"prop-types"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// 只能拥有一个单一的子元素，否则将会打印告警信息。</span></span><br><span class="line">    <span class="keyword">const</span> children = <span class="keyword">this</span>.props.children;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyComponent.propTypes = &#123;</span><br><span class="line">  children: PropTypes.element.isRequired</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="默认的-props-值">默认的 props 值</h2>
<p>可以通过 React 组件的<code>defaultProps</code>属性为<code>props</code>指定默认值。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为props指定默认值</span></span><br><span class="line">Demo.defaultProps = &#123;</span><br><span class="line">  name: <span class="string">"React!"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染出"Hello, React!":</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Demo</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">"app"</span>));</span><br></pre></td></tr></table></figure>
<p>如果你使用了 Babel 的<a href="https://babeljs.io/docs/plugins/transform-class-properties/" target="_blank" rel="noopener">transform-class-properties</a>插件，就可以方便的通过 React 组件类的静态属性来声明默认值，这个语法在 ES6 规范中还没有稳定，因此需要在 Babel 进行编译后才能在浏览器中正常工作。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 通过静态属性来声明默认值</span></span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    name: <span class="string">"React!"</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中的<code>defaultProps</code>属性用来确保<code>this.props.name</code>总是会拥有一个缺省值，<strong>propTypes 检查发生在<code>defaultProps</code>属性被解析之后，因此类型检查机制依然可以应用到<code>defaultProps</code>上面</strong>。</p>
<blockquote>
<p>开发环境下，还可以通过<a href="https://flow.org/" target="_blank" rel="noopener">Flow</a>和<a href="https://www.typescriptlang.org/" target="_blank" rel="noopener">TypeScript</a>进行静态的数据类型检查，可以方便的在代码运行之前检测到数据类型方面的问题。</p>
</blockquote>
<h1 id="refs-和-dom">Refs 和 DOM</h1>
<p>React 组件数据流当中，父组件向下与子组件沟通的唯一方式是通过<code>props</code>，传入新的<code>props</code>值然后子组件被重新渲染。某些场景下（<em>管理输入聚焦、文本选择、多媒体回放，触发命令式动画，整合第 3 方 DOM 类库。</em>），需要在 React 组件数据流范围之外对子元素（<em>即可能是 React 组件，也可能是 DOM 元素</em>）进行修改，为此 React 提供了<code>ref</code>组件属性来满足这种需求。</p>
<h2 id="添加关于-dom-元素的-ref-属性">添加关于 DOM 元素的 ref 属性</h2>
<p>React 提供的<code>ref</code>属性可以添加到任意组件，<code>ref</code>属性接收一个回调函数，该函数会在组件<code>mounted</code>或<code>unmounted</code>后执行。</p>
<p>当<code>ref</code>属性应用于 HTML 元素的时候，<code>ref</code>回调函数会接收到该元素对应的 DOM 对象，例如下面的代码就通过<code>ref</code>存储一个 DOM 结点的引用。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomTextInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.focusTextInput = <span class="keyword">this</span>.focusTextInput.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  focusTextInput() &#123;</span><br><span class="line">    <span class="comment">// 使用原生DOM API显式的聚焦到文本输入框</span></span><br><span class="line">    <span class="keyword">this</span>.textInput.focus();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// 使用ref回调函数，保存一个文本输入域DOM元素的引用到实例属性，比如this.textInput</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"text"</span></span><br><span class="line">          ref=&#123;input =&gt; &#123;</span><br><span class="line">            <span class="keyword">this</span>.textInput = input;</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;input type=<span class="string">"button"</span> value=<span class="string">"Focus the text input"</span> onClick=&#123;<span class="keyword">this</span>.focusTextInput&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>React 会在组件挂载的时候调用<code>ref</code>上的回调函数，然后在组件卸载时将该<code>ref</code>赋值为<code>null</code>；因此，<strong><code>ref</code>上的回调函数先于<code>componentDidMount</code>或<code>componentDidUpdate</code>生命周期函数执行</strong>。</p>
<blockquote>
<p>通过<code>ref</code>回调来设置类上的某个属性是 React 操作局部 DOM 的常见方式，这里推荐使用上面例子中的<strong>行内箭头函数</strong>：<code>ref={input =&gt; this.textInput = input}</code>。</p>
</blockquote>
<h2 id="将-ref-属性引用到当前类组件">将 ref 属性引用到当前类组件</h2>
<p>当<code>ref</code>属性用于自定义类组件的时候，<code>ref</code>回调函数的参数将会接收到被挂载组件的实例，接下来我们为前面的<code>CustomTextInput</code>组件模拟组件挂载后被点击的效果：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoFocusTextInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.textInput.focusTextInput();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;CustomTextInput</span><br><span class="line">        ref=&#123;input =&gt; &#123;</span><br><span class="line">          <span class="keyword">this</span>.textInput = input;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>上面代码只能工作在<code>CustomTextInput</code>以类组件进行声明的时候。</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomTextInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123; <span class="comment">// ... &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="ref-与函数式组件">ref 与函数式组件</h2>
<p>因为函数式组件并不拥有实例对象，因此不可以在<code>ref</code>回调函数中使用<code>this</code>进行赋值操作。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyFunctionalComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// 下面的代码将不会工作！</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;MyFunctionalComponent</span><br><span class="line">        ref=&#123;input =&gt; &#123;</span><br><span class="line">          <span class="keyword">this</span>.textInput = input;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是可以在<code>ref</code>回调函数中通过变量来引用当前组件。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CustomTextInput</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 变量textInput必须先进行声明，以便后续的ref回调函数能够访问到它。</span></span><br><span class="line">  <span class="keyword">let</span> textInput = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    textInput.focus();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type=<span class="string">"text"</span></span><br><span class="line">        ref=&#123;input =&gt; &#123;</span><br><span class="line">          textInput = input;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;input type=<span class="string">"button"</span> value=<span class="string">"Focus the text input"</span> onClick=&#123;handleClick&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="暴露子组件的-dom-引用到父组件">暴露子组件的 DOM 引用到父组件</h2>
<p>极少的情况下（<em>触发子组件的 focus 事件以及尺寸和位置</em>），开发人员需要在父组件访问子组件的 DOM 节点（<em>虽然 React 并不推荐这么做，因为这样会破坏组件的封装性</em>）。</p>
<p>虽然你可以添加一个 ref 到子组件，但这并不是一个理想的解决方案，因为你只会获取到组件实例而非 DOM 节点，而且这样也无法用于函数类型组件。因此，这里推荐在子组件内暴露一个特殊的<code>prop</code>，使子组件能够通过该<code>prop</code>接收到一个任意名称的函数（<em>例如下面函数中的 inputRef</em>），然后通过<code>ref</code>属性将该函数关联到 DOM 节点，最终使得父组件能够通过一个中间层级组件传递其<code>ref</code>回调函数至 DOM 节点，并且这种方式能够同时应用在类组件和函数组件当中，示例代码如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中间层级组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CustomTextInput</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input ref=&#123;props.inputRef&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class Parent extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return &lt;CustomTextInput inputRef=&#123;el =&gt; (this.inputElement = el)&#125; /</span>&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子当中，<code>Parent</code>组件通过<code>CustomTextInput</code>组件的<code>prop.inputRef</code>来传递<code>ref</code>回调函数，而<code>CustomTextInput</code>组件又将该回调函数传递给<code>&lt;input&gt;</code>。因此，<code>Parent</code>组件中的<code>this.inputElement</code>将会被设置为<code>CustomTextInput</code>组件内<code>&lt;input&gt;</code>所对应的 DOM 结点（<strong>非常重要</strong>）。</p>
<p>除了可以同时更加广泛的用于函数式组件和类组件，这种模式的另一个优点在于适用于任意嵌套深度的组件。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CustomTextInput</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input ref=&#123;props.inputRef&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 父组件</span></span><br><span class="line"><span class="regexp">function Parent(props) &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      My input: &lt;CustomTextInput inputRef=&#123;props.inputRef&#125; /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 祖父组件</span></span><br><span class="line"><span class="regexp">class Grandparent extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return &lt;Parent inputRef=&#123;el =&gt; (this.inputElement = el)&#125; /</span>&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面例子中，<code>Grandparent</code>组件需要操纵<code>CustomTextInput</code>组件的 DOM，只需要通过<code>Parent</code>的<code>props</code>进行一次赋值传递，从而让<code>Grandparent</code>组件中的<code>this.inputElement</code>被设置为<code>CustomTextInput</code>组件当中的<code>&lt;input&gt;</code>元素的 DOM。</p>
<blockquote>
<p>出于更全面的考虑，React 官方并不建议直接暴露 DOM 节点对象，但是可以作为一种应急的处理方式。而且这种方式，需要向子组件添加一些功能代码，如果不希望对子组件造成污染，另一个选择是使用<code>ReactDOM.findDOMNode(component)</code>方法。</p>
</blockquote>
<h2 id="遗留-api字符串类型的-ref-属性">遗留 API：字符串类型的 ref 属性</h2>
<p>如果使用早期版本的 React，你可能会熟悉在组件上使用字符串类型的<code>ref</code>属性，例如<code>&lt;input type="text" ref="textInput" /&gt;</code>元素可以通过<code>this.refs.textInput</code>获取其 DOM 节点，但是<strong>目前 React 官方不建议这样做，因为存在一些悬而末决的问题，并且可能在未来 React 发布版本中被移除，所以建议通过上面回调函数的模式去使用<code>ref</code></strong>。</p>
<h2 id="附加说明">附加说明</h2>
<p>如果<code>ref</code>属性是通过行内函数进行定义的，那么在组件更新的时候它将会被调用两次（<em>第 1 次值为<code>null</code>，第 2 次为 DOM 元素</em>），这是因为组件渲染时会建立函数对象的新实例，React 需要清除旧的<code>ref</code>然后设置新的。我们可以通过将<code>ref</code>回调函数定义为类组件方法避免该问题，但是大部份情况下这并不会对开发和用户体验造成影响。</p>
<h1 id="非受控组件-1">非受控组件</h1>
<p>大多数情况下，我们推荐使用<strong>受控组件</strong>去实现表单，即表单数据由 React 组件所控制。另一种方式是使用<strong>非受控组件</strong>，即表单数据由 DOM 对象所控制。</p>
<p>使用非受控组件，可以通过一个<code>ref</code>从 DOM 获取表单值，代替为组件的每次状态更新编写事件处理器，下面示例将会接收一个用户输入的字符串然后弹出。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameForm</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleSubmit = <span class="keyword">this</span>.handleSubmit.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    alert(<span class="string">"被提交的字符串："</span> + <span class="keyword">this</span>.input.value);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          输入的字符串：</span><br><span class="line">          &lt;input type=<span class="string">"text"</span> ref=&#123;input =&gt; (<span class="keyword">this</span>.input = input)&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input type="submit" value="提交" /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>非受控组件能够更加容易的整合 React 以及非 React 代码，而且代码更加精简与小巧，言外之意 React 官方推荐通常情况应使用非受控组件。</p>
<h2 id="默认值">默认值</h2>
<p>在 React 组件的渲染生命周期中，<code>form</code>元素上的<code>value</code>属性将会重写 DOM 上的<code>value</code>属性值。使用非受控组件的时候，通常会希望 React 指定一个能够避免后续非受控更新的初始值，这里需要使用<code>defaultValue</code>来代替原生的<code>value</code>属性。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">      &lt;label&gt;</span><br><span class="line">        名称：&lt;input defaultValue=<span class="string">"Hank"</span> ref=&#123;(input) =&gt; <span class="keyword">this</span>.input = input&#125; type=<span class="string">"text"</span> /&gt;</span><br><span class="line">      &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">      &lt;input type="submit" value="提交" /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>同样的，<code>&lt;input type="checkbox"&gt;</code>和<code>&lt;input type="radio"&gt;</code>支持<code>defaultChecked</code>，<code>&lt;select&gt;</code>和<code>&lt;textarea&gt;</code>支持<code>defaultValue</code>。</p>
<h2 id="文件上传">文件上传</h2>
<p>React 中的<code>&lt;input type="file"&gt;</code>总是属于非受控组件，因为其值只能被用户设置，而非编程控制。</p>
<p>我们可以通过 JavaScript 原生的<code>File API</code>对上传文件进行操作，下面的例子体现了如何通过引用 DOM 节点的<code>ref</code>，在上传事件处理函数中对文件进行操作。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleSubmit = <span class="keyword">this</span>.handleSubmit.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">    alert(<span class="string">`Selected file - <span class="subst">$&#123;<span class="keyword">this</span>.fileInput.files[<span class="number">0</span>].name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          上传文件：</span><br><span class="line">          &lt;input</span><br><span class="line">            type=<span class="string">"file"</span></span><br><span class="line">            ref=&#123;input =&gt; &#123;</span><br><span class="line">              <span class="keyword">this</span>.fileInput = input;</span><br><span class="line">            &#125;&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">        &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">        &lt;br /</span>&gt;</span><br><span class="line">        &lt;button type=<span class="string">"submit"</span>&gt;提交文件&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">FileInput</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">"app"</span>));</span><br></pre></td></tr></table></figure>
<h1 id="fragments-片断">Fragments 片断</h1>
<p>React 组件有时需要返回多个元素，新特性<code>React.Fragment</code>可以在不增加冗余 DOM 节点的情况下，聚合一系列（<em>多个</em>）子元素到 DOM 上去。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;React.Fragment&gt;</span><br><span class="line">      &lt;ChildA /&gt;</span><br><span class="line">      &lt;ChildB /&gt;</span><br><span class="line">      &lt;ChildC /&gt;</span><br><span class="line">    &lt;<span class="regexp">/React.Fragment&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="动机">动机</h2>
<p>当组件需要返回一个列表时，通用的处理方式如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Table组件需要Columns组件渲染单个的表格的数据</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Table</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;table&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">          &lt;Columns /&gt;</span><br><span class="line">        &lt;<span class="regexp">/tr&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>table&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Columns组件需要返回多个&lt;td&gt;元素，让生成的HTML合法可用；但是过去React返回的元素必须拥有一个根元素，因此不得不加上&lt;div&gt;标签。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Columns</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;td&gt;Hello&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">        &lt;td&gt;World&lt;/</span>td&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 最终渲染的结果如下，</span></span><br><span class="line"><span class="regexp">&lt;table&gt;</span></span><br><span class="line"><span class="regexp">  &lt;tr&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;td&gt;Hello&lt;/</span>td&gt;</span><br><span class="line">      &lt;td&gt;World&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  &lt;<span class="regexp">/tr&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>table&gt;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>冗余的<code>&lt;div&gt;</code>元素嵌套在<code>&lt;tr&gt;</code>元素下并不合乎 HTML 规范，因此 React 引入<code>React.Fragment</code>新特性解决这个通点。</p>
</blockquote>
<h2 id="用法">用法</h2>
<p>使用<code>&lt;React.Fragment&gt;</code>改写上面的例子。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Columns</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;React.Fragment&gt;</span><br><span class="line">        &lt;td&gt;Hello&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">        &lt;td&gt;World&lt;/</span>td&gt;</span><br><span class="line">      &lt;<span class="regexp">/React.Fragment&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 最终的输出结果没有冗余的&lt;div&gt;标签</span></span><br><span class="line"><span class="regexp">&lt;table&gt;</span></span><br><span class="line"><span class="regexp">  &lt;tr&gt;</span></span><br><span class="line"><span class="regexp">    &lt;td&gt;Hello&lt;/</span>td&gt;</span><br><span class="line">    &lt;td&gt;World&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>tr&gt;</span><br><span class="line">&lt;<span class="regexp">/table&gt;;</span></span><br></pre></td></tr></table></figure>
<h2 id="快捷语法">快捷语法</h2>
<p>React 16 当中，我们可以使用新添加的<code>fragment</code>快捷语法<code>&lt;&gt;&lt;/&gt;</code>。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Columns</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;td&gt;Hello&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">        &lt;td&gt;World&lt;/</span>td&gt;</span><br><span class="line">      &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Babel 之类的编译工具可能暂不支持<code>fragment</code>快捷语法，因此未受支持的场合可以继续使用<code>&lt;React.Fragment&gt;</code>。</p>
</blockquote>
<h2 id="带-key-属性的-fragment">带 key 属性的 fragment</h2>
<p><code>&lt;React.Fragment&gt;</code>可以拥有一个<code>key</code>属性，用于映射一个集合到 fragment 数组。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Production</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;dl&gt;</span><br><span class="line">      &#123;props.items.map(<span class="function"><span class="params">item</span> =&gt;</span> (</span><br><span class="line">        <span class="comment">// 如果没有提供key属性, React将会提示关于key的警告信息</span></span><br><span class="line">        &lt;React.Fragment key=&#123;item.id&#125;&gt;</span><br><span class="line">          &lt;dt&gt;&#123;item.name&#125;&lt;<span class="regexp">/dt&gt;</span></span><br><span class="line"><span class="regexp">          &lt;dd&gt;&#123;item.info&#125;&lt;/</span>dd&gt;</span><br><span class="line">        &lt;<span class="regexp">/React.Fragment&gt;</span></span><br><span class="line"><span class="regexp">      ))&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>dl&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>key</code>是可以传入<code>Fragment</code>的唯一属性，未来 React 官方可能会增加更为丰富的属性，比如对事件提供支持。</p>
</blockquote>
<h1 id="portals-传送门">Portals 传送门</h1>
<p>Portal（<em>[ˈpɔ:tl] 入口，门户，传送门</em>）用于渲染子元素到一个 DOM 节点，该 DOM 节点可以位于已存在的父元素 DOM 继承树之外。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.createPortal(child, container);</span><br></pre></td></tr></table></figure>
<p>参数<code>child</code>是任意可渲染的 React 子元素（<em>element、string、fragment</em>），而参数<code>container</code>则是一个指定的 DOM 元素。</p>
<h2 id="用法-1">用法</h2>
<p>通常，当你从一个组件的 render()方法返回 HTML 元素的时候，这些元素将会被挂载到相邻父节点 DOM 下面。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="comment">// React将会渲染this.props.children到div下面</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>但是，有时需要插入一个子元素到 DOM 上的不同位置。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="comment">// React不会建立新的div，只会渲染this.props.children到domNode（可以是任意可用的DOM节点，不管其位于DOM中哪个位置）。</span></span><br><span class="line">  <span class="keyword">return</span> ReactDOM.createPortal(</span><br><span class="line">    <span class="keyword">this</span>.props.children,</span><br><span class="line">    domNode,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Portals 可以应用在父组件设置<code>overflow: hidden</code>或<code>z-index</code>样式，子组件需要在视觉上打破其容器（<em>即在指定位置进行层叠展示，例如：对话框、提示信息、浮动卡片</em>）的场景下。</p>
</blockquote>
<h2 id="事件冒泡">事件冒泡</h2>
<p>Portal 可以用于 DOM 树任意位置，其行为类似于普通 React 组件。无论子元素是否是一个 Protal，其上下文特性都是相同的（<em>因为 Protal 仍然存在于 React 组件树当中，而无论其在 DOM 中的真实位置如何</em>），这其中就包括了事件冒泡。</p>
<p>下面例子中，Portal 内触发的事件将会冒泡至 React 组件树的祖先元素，即使它们并不是 DOM 结构意义上的祖先元素：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">"app-root"</span> /&gt;</span><br><span class="line">    &lt;div id=<span class="string">"modal-root"</span> /&gt;</span><br><span class="line">  &lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure>
<p>上面的 HTML 结构当中，父组件中的<code>#app-root</code>（<em>应用根节点</em>）将会响应兄弟节点<code>#modal-root</code>（<em>模态框节点</em>）上的<strong>捕获</strong>或者<strong>冒泡</strong>事件。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 下面2个容器都是DOM节点上的兄弟元素。 */</span></span><br><span class="line"><span class="keyword">const</span> appRoot = <span class="built_in">document</span>.getElementById(<span class="string">"app-root"</span>);</span><br><span class="line"><span class="keyword">const</span> modalRoot = <span class="built_in">document</span>.getElementById(<span class="string">"modal-root"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 封装了按钮元素的Child组件 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// button元素上的click事件将会冒泡至Parent组件。</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"modal"</span>&gt;</span><br><span class="line">      &lt;button&gt;点击我！&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 模态框Modal组件 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Modal</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.el = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// 当Modal的子元素被挂载以后，Portal元素将会被插入到DOM树上，这意味这些子元素将会被添加到真实的DOM结点上。</span></span><br><span class="line">    modalRoot.appendChild(<span class="keyword">this</span>.el);</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    modalRoot.removeChild(<span class="keyword">this</span>.el);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// Modal组件返回Portal</span></span><br><span class="line">    <span class="keyword">return</span> ReactDOM.createPortal(<span class="keyword">this</span>.props.children, <span class="keyword">this</span>.el);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 模态框Parent组件 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">clicks</span>: <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="comment">// 当Child组件的button被点击时，该事件处理函数将会被触发并更新Parent组件的state，即使button并非DOM结构上的直接子孙元素。</span></span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">prevState</span> =&gt;</span> (&#123;</span><br><span class="line">      clicks: prevState.clicks + <span class="number">1</span></span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">        &lt;p&gt;当前点击次数: &#123;<span class="keyword">this</span>.state.clicks&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Modal&gt;</span></span><br><span class="line"><span class="regexp">          &lt;Child /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/Modal&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Parent</span> /&gt;</span></span>, appRoot);</span><br></pre></td></tr></table></figure>
<p>最终生成的 HTML DOM 结构如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app-root"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>当前点击次数: 0<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"modal-root"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span>&gt;</span>点击我！<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="/Web/React/portals.gif" title="示例代码效果"></p>
<blockquote>
<p>从父组件内的 Portal 获取事件冒泡，能够让开发更加灵活和抽象，但是这些抽象并不依赖于 Portal。例如渲染<code>&lt;Modal /&gt;</code>组件时，<code>Parent</code>组件能够捕获它的事件，无论其是否通过 Portal 实现。</p>
</blockquote>
<h1 id="web-components">Web Components</h1>
<p><strong>React</strong>与<strong>Web Components</strong>分别用来解决不同问题，<strong>Web Components</strong>为组件复用提供了强大的封装机制，而<strong>React</strong>则侧重于保持数据与 DOM 的同步，两者相互补充；开发人员可以自由的对两者进行混合使用，尽管开发人员大部分情况只需要使用<strong>React</strong>，但是不排除第三方组件使用到<strong>Web Components</strong>。</p>
<h2 id="在-react-中使用-web-components">在 React 中使用 Web Components</h2>
<p><strong>Web Components</strong>通常需要暴露出命令式 API，例如一个 Video 作为<strong>Web Components</strong>，可能需要暴露<code>play()</code>和<code>pause()</code>两个 API，操作这些命令式 API 需要通过一个引用直接与 DOM 节点进行交互。如果你正在使用第三方提供的<strong>Web Components</strong>，最好的解决方式是使用 React 组件包裹<strong>Web Components</strong>。</p>
<p><strong>Web Components</strong>产生的事件可能不会在 React 的渲染树上正确的进行传播，开发人员将需要在 React 组件当中手动的添加事件处理函数。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloMessage</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        Hello &lt;x-search&gt;&#123;<span class="keyword">this</span>.props.name&#125;&lt;<span class="regexp">/x-search&gt;!</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一个比较常见的混淆是<strong>Web Components</strong>使用了<code>class</code>去替代<code>className</code>。</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BrickFlipbox</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;brick-flipbox <span class="class"><span class="keyword">class</span></span>=<span class="string">"demo"</span>&gt;</span><br><span class="line">      &lt;div&gt;front&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;back&lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/brick-flipbox&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="在-web-components-中使用-react">在 Web Components 中使用 React</h2>
<p>下面的示例代码不能工作在使用 Babel 转译的环境，你可以点击<a href="https://github.com/w3c/webcomponents/issues/587" target="_blank" rel="noopener">这里</a>查看相关 issue。也可以在加载 Web Components 之前，通过名为<a href="https://github.com/webcomponents/webcomponentsjs#custom-elements-es5-adapterjs" target="_blank" rel="noopener">custom-elements-es5-adapter</a>的<strong>polyfill</strong>解决这个问题。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XSearch</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">  connectedCallback() &#123;</span><br><span class="line">    <span class="keyword">const</span> mountPoint = <span class="built_in">document</span>.createElement(<span class="string">"span"</span>);</span><br><span class="line">    <span class="keyword">this</span>.attachShadow(&#123; <span class="attr">mode</span>: <span class="string">"open"</span> &#125;).appendChild(mountPoint);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> name = <span class="keyword">this</span>.getAttribute(<span class="string">"name"</span>);</span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">"https://www.google.com/search?q="</span> + <span class="built_in">encodeURIComponent</span>(name);</span><br><span class="line">    ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#123;url&#125;</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>, mountPoint);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">customElements.define(<span class="string">"x-search"</span>, XSearch);</span><br></pre></td></tr></table></figure>
<h1 id="错误边界">错误边界</h1>
<p>早期 React 版本当中的 JavaScript 错误经常会破坏 React 的内部状态，从而导致整个 Web 应用程序崩溃。为了解决这一问题，新版本的 React 16 引入了一个全新的<strong>错误边界</strong>（<em>或译为错误分界线</em>）特性。</p>
<p><strong>错误边界是一种用于在 React 组件当中捕捉并打印 JavaScript 错误，并显示回调 UI 界面的错误处理机制，可以广泛应用于<code>组件渲染函数</code>、<code>生命周期方法</code>、<code>类组件构造器</code>当中</strong>。</p>
<blockquote>
<p>错误边界<strong>不能</strong>用于<code>事件处理函数</code>、<code>异步处理代码</code>、<code>服务器端渲染</code>、<code>错误边界机制本身抛出的错误</code>一类的场景。</p>
</blockquote>
<p>使用 React 16 新增的生命周期方法<code>componentDidCatch(error, info)</code>即可以使一个 React 组件具备<strong>错误边界</strong>捕获能力。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">hasError</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidCatch(error, info) &#123;</span><br><span class="line">    <span class="comment">// 显示UI界面回调</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">    <span class="comment">// 打印错误信息</span></span><br><span class="line">    logErrorToMyService(error, info);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.hasError) &#123;</span><br><span class="line">      <span class="comment">// 可以渲染任意自定义的UI界面回调</span></span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>提示：发生错误了！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后可以像 React 常规组件那样使用它。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ErrorBoundary&gt;</span><br><span class="line">  &lt;MyWidget /&gt;</span><br><span class="line">&lt;<span class="regexp">/ErrorBoundary&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>componentDidCatch()</code>方法类似于 JavaScript 的<code>catch{}</code>语法，但是对于 React 组件而言，只有类组件能够拥有捕获错误边界的能力。不过实际开发场景下，大部分情况只需定义一个通用的<strong>错误边界组件</strong>，然后在 Web 应用程序其它组件内进行复用。</p>
<p>错误边界组件只能捕获其子组件当中发生的错误，并不能捕获错误边界组件自身产生的问题，例如其自身渲染错误提示信息失败时，此错误会传播到最近的父级错误边界组件处理，此特性与 JavaScript 的<code>catch{}</code>较为相似。</p>
<h2 id="componentdidcatcherror-info的参数">componentDidCatch(error, info)的参数</h2>
<p><code>error</code>是抛出的错误信息；<code>info</code>是一个使用<code>componentStack</code>作为 key 的对象，抛出错误时该属性包含组件堆栈的相关信息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">componentDidCatch(error, info) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 组件堆栈信息示例:</span></span><br><span class="line"><span class="comment">     in ComponentThatThrows (created by App)</span></span><br><span class="line"><span class="comment">     in ErrorBoundary (created by App)</span></span><br><span class="line"><span class="comment">     in div (created by App)</span></span><br><span class="line"><span class="comment">     in App</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  logComponentStackToMyService(info.componentStack);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="错误边界放置位置">错误边界放置位置</h2>
<p>错误边界组件的放置位置完全取决于开发人员的使用习惯，可以放置在顶级路由组件的最外层向用户展示错误信息，也可以用来包裹单独的组件，有效防止单个组件错误引发整个 Web 应用崩溃。</p>
<h2 id="错误捕获的新行为">错误捕获的新行为</h2>
<p><strong>从 React16 开始，没有被任何错误边界捕获的错误将导致整个 React 组件树都被卸载。</strong></p>
<p>Facebook 内部对该决定进行了讨论，在我们的经验中，离开损坏的 UI 比完全删除它的用户体验更加糟糕。例如，像 Messenger 这样的产品中，用户可以看到被破坏的 UI，这可能会导致有人向错误的人发送消息。类似地，支付应用程序显示错误的数量比不提供任何东西的用户体验更加糟糕。</p>
<p>这种变化意味着从老版本迁移到 React 16 时，可能会发现应用程序中存在被忽略的崩溃性错误，因此添加错误边界可以在出现问题时提供更好的用户体验。</p>
<blockquote>
<p>例如，Facebook 的 Messenger 将侧边栏、信息面板、对话日志、消息输入内容封装到单独的错误边界中。如果这些 UI 区域中的某个组件崩溃，剩下的部分仍然能够正常响应用户的交互。</p>
</blockquote>
<h2 id="组件堆栈记录">组件堆栈记录</h2>
<p>React 16 可以自动打印开发时产生的错误至浏览器控制台，除了错误信息和 JavaScript 堆栈之外，还提供了组件堆栈记录，让开发人员能够更加清晰的了解组件树中发生的故障。<strong>该特性只用于开发，生产中必须禁用</strong>。</p>
<p><img src="/Web/React/error-boundaries-stack-trace.png" title="组件堆栈记录"></p>
<p>如果 Web 应用是由<a href="https://github.com/facebook/create-react-app" target="_blank" rel="noopener">create-react-app</a>搭建，或是手动安装了<a href="https://github.com/babel/babel/tree/master/packages/babel-plugin-transform-react-jsx-source" target="_blank" rel="noopener">babel-plugin-transform-react-jsx-source</a>插件，组件堆栈记录当中还能够展示<strong>文件名</strong>、<strong>行号</strong>。</p>
<p><img src="/Web/React/error-boundaries-stack-trace-line-numbers.png" title="带行号的组件堆栈记录"></p>
<blockquote>
<p>堆栈记录当中组件名称的展示依赖于 JavaScript 原生的<code>Function.name</code>属性，如果使用 IE11 等还未支持该属性的浏览器，就需要单独安装<a href="https://github.com/JamesMGreene/Function.name" target="_blank" rel="noopener">Function.name Polyfill</a>进行兼容，或者在组件定义时显式的设置<code>displayName</code>属性。</p>
</blockquote>
<h2 id="使用-trycatch">使用 try/catch</h2>
<p><code>try/catch</code>只对命令式代码有效，但是 React 组件都是声明式的，并且能够指定渲染的内容。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  showButton();</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;Button /&gt;;</span><br></pre></td></tr></table></figure>
<p><strong>错误边界</strong>保留了 React 的声明特性，让代码按照预期的方式执行。例如在<code>componentdidupdate()</code>生命周期方法内使用<code>setState()</code>出现错误，这些错误仍将正确传播到最近的<strong>错误边界</strong>。</p>
<h2 id="使用事件处理器">使用事件处理器</h2>
<p><strong>错误边界</strong>不能捕捉到事件处理函数内发生的错误，因为 React 并不需要处理事件函数内产生的错误。不同于<code>render()</code>和其它组件生命周期函数，组件内的事件处理函数不会在组件渲染期间得到执行。因此当有错误被抛出的时候，React 会将其显示到屏幕上。</p>
<p>如果需要在事件处理函数内捕捉错误信息，建议使用 JavaScript 传统的<code>try/catch</code>语句。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">error</span>: <span class="literal">null</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 抛出错误的代码</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; error &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.error) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>捕捉到错误！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>点击我！<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="reconciliation-调和">Reconciliation 调和</h1>
<p><strong>Reconciliation</strong>（<em>[,rek(ə)nsɪlɪ'eɪʃ(ə)n] n.调和</em>）是 React 提供的一种<strong>比较算法</strong>，能够让 React 组件的更新可以预测，并且提供了更优秀的 DOM 渲染性能。</p>
<p>使用 React 的过程中，可以通过<code>render()</code>函数来创建 React 元素。当<code>state</code>或<code>props</code>更新时将返回不同的 React 元素树，此时 React 需要考量如何更加高效的将变化反映到 UI 上去。</p>
<p>对于<strong>将一棵树状数据结构同步到另外一棵树</strong>的最小操作数算法问题，虽然有一些通用的解决方案，比如<strong>art 算法</strong>（<em>参见<a href="https://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf" target="_blank" rel="noopener">《关于树的编辑深度与相关问题的研究》</a></em>）复杂度为<strong>O(n<sup>3<sup>)</sup></sup></strong>，其中<strong>n</strong>是 React 元素树上元素的个数。如果在 React 中使用该算法，显示 1000 个元素将需要 10 亿次比较操作，性能开销极为昂贵。</p>
<p>因此，React 根据如下 2 个假设实现了一套启发式<strong>O(n)</strong>算法：</p>
<ol type="1">
<li>不同类型的 2 个元素会产生不同的树。</li>
<li>通过名为<code>key</code>的<code>props</code>来提示哪些子元素在不同渲染过程中是稳定的。</li>
</ol>
<blockquote>
<p>在实践中，上述假设对于几乎所有用例都是有效的。</p>
</blockquote>
<h2 id="diffing-算法">Diffing 算法</h2>
<p>比较两颗树的时候，React 首先会比较其根元素，根据根元素的类型来判断行为的不同。</p>
<h3 id="不同类型的元素">不同类型的元素</h3>
<p>每当根元素类型不同时，React 都会推倒旧的树并从头构建新的树。从<code>&lt;a&gt;</code>到<code>&lt;img&gt;</code>、<code>&lt;Article&gt;</code>到<code>&lt;Comment&gt;</code>、<code>&lt;Button&gt;</code>到<code>&lt;div&gt;</code>，这些情况都会导致推倒重建。</p>
<p>React 推倒旧树意味其 DOM 节点将被销毁，组件实例执行<code>componentWillUnmount()</code>方法。构建新树意味新的 DOM 节点被插入，组件实例执行<code>componentWillMount()</code>以及<code>componentDidMount()</code>方法，此时旧树上关联的<code>state</code>将会完全消失。</p>
<p>下面例子当中，旧的<code>Counter</code>组件会被卸载，其状态也将被销毁，然后新的<code>Counter</code>组件将会被挂载至 DOM。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 旧树 */</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;Counter /&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span>* 新树 *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">&lt;span&gt;</span></span><br><span class="line"><span class="regexp">  &lt;Counter /</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/span&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="相同类型的-dom-元素">相同类型的 DOM 元素</h3>
<p>比较两个相同类型的 DOM 元素时，React 首先检查 2 个元素的属性，并保证相同的底层 DOM 节点，然后只更新属性发生更改的那一部分。</p>
<p>下面例子当中，React 只会更新<code>className</code>发生改变了的组件所对应的 DOM 节点。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 旧DOM */</span></span><br><span class="line">&lt;div className=<span class="string">"before"</span> title=<span class="string">"stuff"</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 新DOM */</span></span><br><span class="line">&lt;div className=<span class="string">"after"</span> title=<span class="string">"stuff"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>当更新<code>style</code>属性时，React 依然会只更新<code>style</code>发生改变的那部分 DOM 节点。</p>
<p>下面例子中，React 只会修改<code>color</code>样式，而不是<code>fontWeight</code>样式。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 旧DOM */</span></span><br><span class="line">&lt;div style=&#123;&#123;<span class="attr">color</span>: <span class="string">'red'</span>, <span class="attr">fontWeight</span>: <span class="string">'bold'</span>&#125;&#125; /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 新DOM */</span></span><br><span class="line">&lt;div style=&#123;&#123;<span class="attr">color</span>: <span class="string">'green'</span>, <span class="attr">fontWeight</span>: <span class="string">'bold'</span>&#125;&#125; /&gt;</span><br></pre></td></tr></table></figure>
<p><strong>处理 DOM 节点之后，React 将会递归的处理其它子元素</strong>。</p>
<h3 id="相同类型的-react-组件元素">相同类型的 React 组件元素</h3>
<p>当 React 组件更新的时候，组件实例保持不变，因此<code>state</code>在渲染时也将被实例所维护。React 更新组件实例的<code>props</code>使之匹配新的元素，并调用该组件实例上的<code>componentWillReceiveProps()</code>和<code>componentWillUpdate()</code>方法。最后<code>render()</code>方法会被调用，比较算法将会递归的展示新的渲染结果。</p>
<h3 id="递归处理子元素">递归处理子元素</h3>
<p>默认情况下，递归 DOM 节点的子节点时，每当出现差异，React 都只遍历子元素列表。</p>
<p>例如，当添加一个子元素到无序列表尾部时，React 将会首先匹配两颗树的<code>&lt;li&gt;first&lt;/li&gt;</code>，然后是<code>&lt;li&gt;second&lt;/li&gt;</code>，最后插入<code>&lt;li&gt;third&lt;/li&gt;</code>。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 旧DOM */</span></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;first&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  &lt;li&gt;second&lt;/</span>li&gt;</span><br><span class="line">&lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span>* 新DOM *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">&lt;ul&gt;</span></span><br><span class="line"><span class="regexp">  &lt;li&gt;first&lt;/</span>li&gt;</span><br><span class="line">  &lt;li&gt;second&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  &lt;li&gt;third&lt;/</span>li&gt;  <span class="comment">// 增加的项</span></span><br><span class="line">&lt;<span class="regexp">/ul&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果需要插入元素到无序列表<code>&lt;li&gt;</code>子元素开头的位置，那么将会得到比较差的性能，例如需要转换下面的 2 颗 DOM 树：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 旧DOM */</span></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;first&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  &lt;li&gt;second&lt;/</span>li&gt;</span><br><span class="line">&lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span>* 新DOM *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">&lt;ul&gt;</span></span><br><span class="line"><span class="regexp">  &lt;li&gt;zero&lt;/</span>li&gt;  <span class="comment">// 增加的项</span></span><br><span class="line">  &lt;li&gt;first&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  &lt;li&gt;second&lt;/</span>li&gt;</span><br><span class="line">&lt;<span class="regexp">/ul&gt;</span></span><br></pre></td></tr></table></figure>
<p>React 将会改变每个子元素，并保持<code>&lt;li&gt;first&lt;/li&gt;</code>和<code>&lt;li&gt;second&lt;/li&gt;</code>不变，这样性能将是一个问题。</p>
<h3 id="keys">Keys</h3>
<p>为了解决上面遗留的问题，React 通过旧 DOM 树上的<code>key</code>属性去匹配原始 DOM 树上的元素，从而有效的区分出需要更新的部分。</p>
<p>现在，为上面的示例代码添加上不同的<code>key</code>属性，让 React 明确的知道哪个 DOM 结点发生了更新。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 旧DOM */</span></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li key=<span class="string">"1"</span>&gt;first&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  &lt;li key="2"&gt;second&lt;/</span>li&gt;</span><br><span class="line">&lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span>* 新DOM *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">&lt;ul&gt;</span></span><br><span class="line"><span class="regexp">  &lt;li key="0"&gt;zero&lt;/</span>li&gt;   <span class="comment">// 增加的项</span></span><br><span class="line">  &lt;li key=<span class="string">"1"</span>&gt;first&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  &lt;li key="2"&gt;second&lt;/</span>li&gt;</span><br><span class="line">&lt;<span class="regexp">/ul&gt;</span></span><br></pre></td></tr></table></figure>
<p>日常开发场景当中，<strong><code>key</code>属性值的 ID 在其同胞元素中必须是唯一的</strong>（<em>并非全局唯一</em>），因此可以手动进行设置，或是使用工具生成 Hash，再或者是通过绑定的动态数据。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;li key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;<span class="regexp">/li&gt;</span></span><br></pre></td></tr></table></figure>
<p>万不得已的时候，如果每个数据项不需要再进行排序，那么可以使用其索引值<code>index</code>作为<code>key</code>，但是负作用是重新排序的时候会变得非常缓慢。另外，使用数组索引作为<code>key</code>，重新排序还会引发组件状态方面的问题，即移动其中一项并改变它时，会导致受控输入类组件的状态被混淆，并以不被期待的方式更新。</p>
<h2 id="权衡">权衡</h2>
<p>重新渲染当前上下文意味着调用当前所有组件的<code>render()</code>方法，这并不意味 React 将会卸载或者重新挂载这些组件，React 只会按照上述规则对 DOM 结构进行局部的更新。</p>
<p>为了让大部分用例运行更加快速，社区经常对 React 的策略进行改进。在当前实现中，React 子树的每项 DOM 元素都只是在其兄弟元素之间移动，而非在整个页面的 DOM 结构（<em>会造成惊人的性能开销</em>）。</p>
<p>由于 React 依赖于启发式算法，使用的时候需要注意以下两点：</p>
<ol type="1">
<li>该算法不会尝试匹配不同组件类型的子树，如果两个自定义组件类型具有非常相似的输出，那么可以考虑将其归为一个相同类型。</li>
<li><code>key</code>值应该是稳定的、可预测的、唯一的；不稳定的键（<em>比如<code>math.random()</code>生成的键</em>）会导致许多组件实例和 DOM 节点被不必要的重新创建，这将会导致性能的下降，并让子组件丢失状态。</li>
</ol>
<h1 id="context-组件树上下文">Context 组件树上下文</h1>
<p>Context 提供了一种在组件树当中传递数据的方式，而毋需手动在每层组件通过<code>props</code>进行传递。</p>
<p>下面的例子代码当中，为了按钮组件的样式而手动传递了一个名为<code>theme</code>的<code>props</code>。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Toolbar</span> <span class="attr">theme</span>=<span class="string">"dark"</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Toolbar</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Toolbar组件必须接收一个theme属性，并且将其它传递给ThemedButton。这个过程将会比较痛苦，因为应用当中的每个按钮都需要这个theme属性。</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;ThemedButton theme=&#123;props.theme&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function ThemedButton(props) &#123;</span></span><br><span class="line"><span class="regexp">  return &lt;Button theme=&#123;props.theme&#125; /</span>&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>context</code>，我们可以避免向一些中间层级的组件传递<code>props</code>。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Context可以让开发人员向组件树透传一个值，而不需要在每层组件进行声明。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为当前theme建立一个默认值为light的context</span></span><br><span class="line"><span class="keyword">const</span> ThemeContext = React.createContext(<span class="string">"light"</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// 通过Provider传递当前theme到下面组件树（App➜Toolbar➜ThemedButton）。任意组件都可以进行读取，无论其所处的深度如何。</span></span><br><span class="line">    <span class="comment">// 这个例子中，我们可以传递dark作为当前值。</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ThemeContext.Provider value=<span class="string">"dark"</span>&gt;</span><br><span class="line">        &lt;Toolbar /&gt;</span><br><span class="line">      &lt;<span class="regexp">/ThemeContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 位于中间层级的Toolbar组件并不需要显式的传递theme到子级组件。</span></span><br><span class="line"><span class="regexp">function Toolbar(props) &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ThemedButton /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function ThemedButton(props) &#123;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 使用一个Consumer去读取当前的context中的theme，React将会查找最近theme的Provider并使用它的值。</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 这个例子当中，当前的theme值为dark。</span></span><br><span class="line"><span class="regexp">  return &lt;ThemeContext.Consumer&gt;&#123;theme =&gt; &lt;Button &#123;...props&#125; theme=&#123;theme&#125; /</span>&gt;&#125;&lt;<span class="regexp">/ThemeContext.Consumer&gt;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="react.createcontext">React.createContext</h2>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Provider, Consumer &#125; = React.createContext(defaultValue);</span><br></pre></td></tr></table></figure>
<p>通过<code>createContext()</code>这个 API 获取<code>{ Provider, Consumer }</code>对象，当 React 渲染一个 Context 的<code>Consumer</code>时，它将会从闭合的<code>Provider</code>当中读取当前的 Context 值。当渲染一个没有匹配<code>Provider</code>的<code>Consumer</code>时，<code>defaultValue</code>参数用于提供一个默认值，从而有助于对组件进行独立测试。</p>
<h2 id="provider">Provider</h2>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Provider 以=&#123;<span class="comment">/* 某个值 */</span>&#125;&gt;</span><br></pre></td></tr></table></figure>
<p>一个 React 组件允许<code>Consumer</code>去订阅 Context 的变化。<code>value</code>的值会被传递到<code>Provider</code>的子级<code>Consumer</code>当中，一个<code>Provider</code>能够连接到多个<code>Consumer</code>，<code>Provider</code>可以被嵌套以覆盖组件树上更深层的位置。</p>
<h2 id="consumer">Consumer</h2>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Consumer&gt;</span><br><span class="line">  &#123;value =&gt; <span class="comment">/* 基于context的值进行渲染 */</span>&#125;</span><br><span class="line">&lt;<span class="regexp">/Consumer&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码定义了一个订阅 Context 变化的组件。</p>
<p>需要一个函数作为组件的子元素，该函数会接收当前 Context 值并返回一个 React 节点。这个传入函数的参数将会等同于当前组件树上 Context 相临的 Provider 值，如果 Context 相应的 Provider 不存在，那么该参数的值将会等于传递至<code>createContext()</code>的<code>defaultValue</code>值。</p>
<p>无论 Provider 的值如何变化，所有 Consumer 都会重新进行渲染。这种变化取决于使用<code>Object.is</code>类似算法所进行的新旧值比较（<em>当传递对象作为值时，可能会导致一些问题，参见注意事项</em>）。</p>
<h2 id="一个完整的例子">一个完整的例子</h2>
<p>首先定义一个 Store，并将其代码放置到一个单独的文件<code>store.js</code>当中。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Flux = &#123;</span><br><span class="line">  Store: &#123;</span><br><span class="line">    <span class="comment">/** Search Form */</span></span><br><span class="line">    form: &#123;&#125;,</span><br><span class="line">    <span class="comment">/** Result Table */</span></span><br><span class="line">    table: [],</span><br><span class="line">    <span class="comment">/** Pop Modal */</span></span><br><span class="line">    modal: &#123;</span><br><span class="line">      add: <span class="literal">false</span>,</span><br><span class="line">      auth: <span class="literal">false</span>,</span><br><span class="line">      history: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  setStore: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Context = React.createContext(Flux);</span><br></pre></td></tr></table></figure>
<p>然后添加<code>Provider</code>，将<code>&lt;SearchForm /&gt;</code>、<code>&lt;ResultTable /&gt;</code>两个子组件的状态全部提升至<code>index.jsx</code>组件，并且引入上面定义的 Store 对象并且定义其对应的钩子函数，便于两个子组件当中的数据进行双向绑定。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"./style.scss"</span>;</span><br><span class="line"><span class="keyword">import</span> SearchForm <span class="keyword">from</span> <span class="string">"./search-form"</span>;</span><br><span class="line"><span class="keyword">import</span> ResultTable <span class="keyword">from</span> <span class="string">"./result-table"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Context, Flux &#125; <span class="keyword">from</span> <span class="string">"./store"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      Store: Flux.Store,</span><br><span class="line">      setStore: <span class="function"><span class="params">newState</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(<span class="function"><span class="params">oldState</span> =&gt;</span> (&#123;</span><br><span class="line">          Store: &#123;</span><br><span class="line">            ...newState,</span><br><span class="line">            ...oldState</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div id=<span class="string">"demo"</span>&gt;</span><br><span class="line">        &lt;Context.Provider value=&#123;<span class="keyword">this</span>.state&#125;&gt;</span><br><span class="line">          &lt;SearchForm /&gt;</span><br><span class="line">          &lt;ResultTable /&gt;</span><br><span class="line">        &lt;<span class="regexp">/Context.Provider&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，就可以在两个子组件内，通过<code>Consumer</code>获取 Context 传入的<code>Store</code>对象以及<code>setStore()</code>钩子函数，完成跨组件的双向绑定。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> ModalAuth <span class="keyword">from</span> <span class="string">"./modal-auth"</span>;</span><br><span class="line"><span class="keyword">import</span> ModalHistory <span class="keyword">from</span> <span class="string">"./modal-history"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Context &#125; <span class="keyword">from</span> <span class="string">"../store"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultTable</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Context.Consumer&gt;</span><br><span class="line">        &#123;(&#123; Store, setStore &#125;) =&gt; (</span><br><span class="line">          &lt;React.Fragment&gt;</span><br><span class="line">            &#123;<span class="comment">/* 修改Store中的属性值 */</span>&#125;</span><br><span class="line">            &lt;Table</span><br><span class="line">              onClick=&#123;() =&gt; &#123;</span><br><span class="line">                setStore(&#123;</span><br><span class="line">                  modal: &#123;</span><br><span class="line">                    add: <span class="literal">true</span></span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">              &#125;&#125;</span><br><span class="line">            /&gt;</span><br><span class="line">            &#123;<span class="comment">/* 使用Store里的属性值 */</span>&#125;</span><br><span class="line">            &lt;h1&gt;&#123;Store.modal.add&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">            &lt;ModalAuth /</span>&gt;</span><br><span class="line">            &lt;ModalHistory /&gt;</span><br><span class="line">          &lt;<span class="regexp">/React.Fragment&gt;</span></span><br><span class="line"><span class="regexp">        )&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>Context.Consumer&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>虽然 React 在<code>16.0</code>版本以后重写了<code>Context API</code>，并移除出了官方文档中的不建议使用标识，但是受限于<code>&lt;Consumer&gt;</code>必需在组件<code>render()</code>函数内进行传值，笔者依然建议开发人员在进行跨组件通信时，选用 Reflux、Redux、Mobx 等专用的状态管理工具。</p>
</blockquote>
<h1 id="accessibility-可访问性">Accessibility 可访问性</h1>
<p>Web 可访问性（<em>Web accessibility</em>）也被称为<strong>a11y</strong>，用于构建适宜所有人群访问的页面。JSX 支持所有<code>aria-*</code>的 HTML 属性，这些特性在 React 当中全部采用小写：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input aria-label=&#123;labelText&#125; aria-required=<span class="string">"true"</span> type=<span class="string">"text"</span> onChange=&#123;onchangeHandler&#125; value=&#123;inputValue&#125; name=<span class="string">"name"</span> /&gt;</span><br></pre></td></tr></table></figure>
<h2 id="语义化-html">语义化 HTML</h2>
<p>语义化的 HTML 是 Web 应用程序可访问性的基础。JSX 当中添加<code>&lt;div&gt;</code>元素会破坏 DOM 的语义结构，特别是在使用了列表元素<code>&lt;ol&gt;</code>、<code>&lt;ul&gt;</code>、<code>&lt;dl&gt;</code>、<code>&lt;table&gt;</code>的情况下，此时应该使用 React 片段（<em>Fragment</em>）将多个元素组合到一起。</p>
<p>通常情况下使用<code>&lt;&gt;&lt;/&gt;</code>语法：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ListItem</span>(<span class="params">&#123; item &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;dt&gt;&#123;item.term&#125;&lt;<span class="regexp">/dt&gt;</span></span><br><span class="line"><span class="regexp">      &lt;dd&gt;&#123;item.description&#125;&lt;/</span>dd&gt;&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>进行列表遍历操作时需要使用到<code>key</code>属性，此时可以使用<code>&lt;Fragment&gt;</code>：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Fragment &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Glossary</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;dl&gt;</span><br><span class="line">      &#123;props.items.map(<span class="function"><span class="params">item</span> =&gt;</span> (</span><br><span class="line">        <span class="comment">// Without the `key`, React will fire a key warning</span></span><br><span class="line">        &lt;Fragment key=&#123;item.id&#125;&gt;</span><br><span class="line">          &lt;dt&gt;&#123;item.term&#125;&lt;<span class="regexp">/dt&gt;</span></span><br><span class="line"><span class="regexp">          &lt;dd&gt;&#123;item.description&#125;&lt;/</span>dd&gt;</span><br><span class="line">        &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">      ))&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>dl&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="可访问表单的label">可访问表单的<code>&lt;label&gt;</code></h2>
<p>一些 HTML 表单控件（<em>例如<code>&lt;input&gt;</code>和<code>&lt;textarea&gt;</code></em>）需要添加<code>&lt;label&gt;&lt;/label&gt;</code>作为可访问标签，HTML 中的<code>for</code>属性在 JSX 当中会写为<code>htmlFor</code>，例如下面的代码：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;label htmlFor=<span class="string">"namedInput"</span>&gt;Name:&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">&lt;input id="namedInput" type="text" name="name"/</span>&gt;</span><br></pre></td></tr></table></figure>
<h2 id="输入焦点管理">输入焦点管理</h2>
<p>React 应用在运行期间会不断对 DOM 进行修改，这可能会导致键盘焦点丢失或定位到未知元素，此时可以通过 JavaScript 代码进行修正。</p>
<p>首先，在类组件的 JSX 当中添加一个<code>ref</code>属性：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomTextInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.textInput = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  focus() &#123;</span><br><span class="line">    <span class="comment">// 使用DOM原生API聚焦输入域，</span></span><br><span class="line">    <span class="keyword">this</span>.textInput.current.focus();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// 建立一个ref保存textInput的DOM元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">ref</span>=<span class="string">&#123;this.textInput&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有时候，父级组件需要去设置一个聚焦到子级组件的元素上，我们可以通过子级组件上的一个特殊<code>prop</code>暴露 DOM 的<code>ref</code>给父级组件，从而将父级的<code>ref</code>传递到子级的 DOM。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CustomTextInput</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input ref=&#123;props.inputRef&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class Parent extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  constructor(props) &#123;</span></span><br><span class="line"><span class="regexp">    super(props);</span></span><br><span class="line"><span class="regexp">    this.inputElement = React.createRef();</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;CustomTextInput inputRef=&#123;this.inputElement&#125; /</span>&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在可以按需设置聚焦事件了</span></span><br><span class="line"><span class="keyword">this</span>.inputElement.current.focus();</span><br></pre></td></tr></table></figure>
<p>当使用高阶组件去继承组件时，推荐通过使用 React 的<code>forwardRef()</code>函数转发<code>ref</code>到被包裹的组件，如果第三方高阶组件没有实现<strong>ref 转发</strong>，上面的模式依然可以作为一种回退。</p>
<blockquote>
<p>尽管上述内容对于可访问性非常重要，但也应该审慎进行应用，总是在聚焦事件发生中断时去修复键盘的焦点。</p>
</blockquote>
<h1 id="代码切割">代码切割</h1>
<p>在与 Webpack 共同使用的场景下，伴随 Web 应用的增长，打包文件的体积也会快速的增长，因为需要引入<strong>代码拆分</strong>特性，切分并且懒加载脚本代码，从而优化前端的用户性能与体验。</p>
<h2 id="import"><code>import()</code></h2>
<p>引入<strong>代码拆分</strong>最简单的方式是通过 Webpack 提供的<code>import()</code>语法，Babel 上可以通过<a href="https://www.npmjs.com/package/babel-plugin-syntax-dynamic-import" target="_blank" rel="noopener">babel-plugin-syntax-dynamic-import</a>添加支持。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 过去</span></span><br><span class="line"><span class="keyword">import</span> &#123; add &#125; <span class="keyword">from</span> <span class="string">"./math"</span>;</span><br><span class="line"><span class="built_in">console</span>.info(add(<span class="number">16</span>, <span class="number">26</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在</span></span><br><span class="line"><span class="keyword">import</span>(<span class="string">"./math"</span>).then(<span class="function"><span class="params">math</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.info(math.add(<span class="number">156</span>, <span class="number">98</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>import()</code>语法目前还处于 ECMAScript 提案阶段，不久的将来可能会成为标准。</p>
</blockquote>
<h2 id="react-loadable">react-loadable</h2>
<p><a href="https://github.com/jamiebuilds/react-loadable" target="_blank" rel="noopener">react-loadable</a>是一个封装良好的、能够实现动态导入的高阶组件，能够对 React 应用程序中的组件进行动态的拆分。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 过去 */</span></span><br><span class="line"><span class="keyword">import</span> OtherComponent <span class="keyword">from</span> <span class="string">"./OtherComponent"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyComponent = <span class="function"><span class="params">()</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">OtherComponent</span> /&gt;</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 现在 */</span></span><br><span class="line"><span class="keyword">import</span> Loadable <span class="keyword">from</span> <span class="string">"react-loadable"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LoadableOtherComponent = Loadable(&#123;</span><br><span class="line">  loader: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">"./OtherComponent"</span>),</span><br><span class="line">  loading: <span class="function"><span class="params">()</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyComponent = <span class="function"><span class="params">()</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">LoadableOtherComponent</span> /&gt;</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="基于路由进行切割">基于路由进行切割</h2>
<p>基于路由进行代码拆分是一种相对合理的打包策略，下面示例代码中通过<a href="https://reacttraining.com/react-router" target="_blank" rel="noopener">react-router</a>和<a href="https://github.com/jamiebuilds/react-loadable" target="_blank" rel="noopener">react-loadable</a>展示了如何通过路由完成代码的切割。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Loadable <span class="keyword">from</span> <span class="string">"react-loadable"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BrowserRouter <span class="keyword">as</span> Router, Route, Switch &#125; <span class="keyword">from</span> <span class="string">"react-router-dom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Loading = <span class="function"><span class="params">()</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Home = Loadable(&#123;</span><br><span class="line">  loader: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">"./routes/Home"</span>),</span><br><span class="line">  loading: Loading</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> About = Loadable(&#123;</span><br><span class="line">  loader: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">"./routes/About"</span>),</span><br><span class="line">  loading: Loading</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;Router&gt;</span><br><span class="line">    &lt;Switch&gt;</span><br><span class="line">      &lt;Route exact path=<span class="string">"/"</span> component=&#123;Home&#125; /&gt;</span><br><span class="line">      &lt;Route path=<span class="string">"/about"</span> component=&#123;About&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>Router&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h1 id="整合-jquery">整合 jQuery</h1>
<p>如果需要整合 React 与 jQuery，可以在组件的 DOM 根元素上添加<code>ref</code>属性，并在<code>componentDidMount()</code>当中调用该<code>ref</code>并将其传递给 jQuery 插件，最后在<code>componentWillUnmount()</code>移除 DOM 上绑定的事件。同时，为了防止 React 组件加载之后修改 DOM 节点，需要先在<code>render()</code>方法中返回一个空的<code>&lt;div /&gt;</code>，这样 React 就不会对其进行更新，封装的 jQuery 插件就可以任意修改该节点。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomePlugin</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.$el = $(<span class="keyword">this</span>.el);</span><br><span class="line">    <span class="keyword">this</span>.$el.somePlugin();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.$el.somePlugin(<span class="string">"destroy"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;el</span> =&gt;</span> (this.el = el)&#125; /&gt;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="高阶组件">高阶组件</h1>
<p>高阶组件本质是一个函数，能够接受一个组件并返回一个新的组件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EnhancedComponent = higherOrderComponent(WrappedComponent);</span><br></pre></td></tr></table></figure>
<h1 id="render-props">Render Props</h1>
<p>Render Props 是一种将组件的 Props 设置为函数，从而通过传入参数共享数据并动态决定所需要渲染组件的模式。下面是一个动态获取当前鼠标位置的示例代码，<code>MouseTracker</code>是用于渲染的根组件，<code>Picture</code>实时获取鼠标的坐标位置并使组件渲染的图片与鼠标实时联动，<code>MousePosition</code>用于获取鼠标的当前位置，并将状态通过<code>render(this.state)</code>传递给<code>Picture</code>组件。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Picture Component */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Picture</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> mouse = <span class="keyword">this</span>.props.mouse;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/images/picture.png"</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">position:</span> "<span class="attr">absolute</span>", <span class="attr">left:</span> <span class="attr">mouse.x</span>, <span class="attr">top:</span> <span class="attr">mouse.y</span> &#125;&#125; /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Mouse Component */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MousePosition</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleMouseMove = <span class="keyword">this</span>.handleMouseMove.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleMouseMove(event) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      x: event.clientX,</span><br><span class="line">      y: event.clientY</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div style=&#123;&#123; <span class="attr">height</span>: <span class="string">"100%"</span> &#125;&#125; onMouseMove=&#123;<span class="keyword">this</span>.handleMouseMove&#125;&gt;</span><br><span class="line">        &#123;<span class="comment">/* 使用render prop动态决定需要渲染的组件，代替直接去渲染静态&lt;Mouse&gt;组件。*/</span>&#125;</span><br><span class="line">        &#123;<span class="keyword">this</span>.props.render(<span class="keyword">this</span>.state)&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class MouseTracker extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;h1&gt;移动鼠标！&lt;/</span>h1&gt;</span><br><span class="line">        &#123;<span class="comment">/* 为Mouse组件设置的render props是一个函数*/</span>&#125;</span><br><span class="line">        &lt;MousePosition render=&#123;mouse =&gt; <span class="xml"><span class="tag">&lt;<span class="name">Picture</span> <span class="attr">mouse</span>=<span class="string">&#123;mouse&#125;</span> /&gt;</span></span>&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Render Props 本质是一种 Context 机制之外的组件间状态共享机制。</p>
</blockquote>
<h1 id="严格模式与性能优化">严格模式与性能优化</h1>
<p>严格模式用于在开发模式下检查 React 应用中潜在的问题，目前能够识别的问题如下：</p>
<ul>
<li>识别具有不安全生命周期的组件。</li>
<li>有关废弃的字符串 ref 用法的警告。</li>
<li>关于已弃用的 findDOMNode 用法的警告。</li>
<li>检测意外的副作用。</li>
<li>检测遗留的 context API。</li>
</ul>
<p>只需在要进行严格检查的组件上添加父组件<code>&lt;React.StrictMode&gt;</code>即可开启严格模式，具体使用请参见以下代码：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrictCheck</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;React.StrictMode&gt;</span><br><span class="line">          &lt;SomeCompenent /&gt;</span><br><span class="line">        &lt;<span class="regexp">/React.StrictMode&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Webpack 编译打包的时候（<em>生产环境</em>）可以通过添加下面代码来优化编译过程。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">  <span class="string">"process.env"</span>: &#123;</span><br><span class="line">    NODE_ENV: <span class="built_in">JSON</span>.stringify(<span class="string">"production"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;),</span><br><span class="line">  <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin();</span><br></pre></td></tr></table></figure>
<p>虽然 React 只是按需更新 DOM 节点，但是诸如多次输入事件不断触发时，会造成组件的<code>render()</code>函数被不停的渲染，这里可以通过<code>shouldComponentUpdate</code>避免这个问题。React 生命周期函数<code>shouldComponentUpdate</code>会在组件重绘前执行，该函数默认返回<code>true</code>，如果遇到组件不需要更新的情况，可以让该函数返回<code>false</code>从而避免组件被重绘。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="react-router-4">React Router 4</h1>
<p>Rails、Express、Ember、Angular 使用的是<strong>静态路由</strong>机制（<em>Static Routing</em>），即将路由作为 Web 应用初始化的一部分，React Router 4 之前的版本也采用相同的机制。</p>
<p><strong>动态路由</strong>（<em>Dynamic Routing</em>）是指的 Web 应用程序渲染的时候发生的路由，而非正在运行的 Web 应用程序之外的配置和约定，这意味着 React Router 当中的一切都是组件。</p>
<h2 id="基本组件">基本组件</h2>
<p>React Router 拥有 3 种组件：路由组件、路由匹配的组件、导航组件，这些组件都可以通过<code>react-router-dom</code>引入。</p>
<h3 id="routers">Routers</h3>
<p>Web 应用程序的核心是路由组件，<code>react-router-dom</code>提供了<code>&lt;BrowserRouter&gt;</code>和<code>&lt;HashRouter&gt;</code>两种路由组件，它们都会去建立一个特殊的<code>history</code>对象。如果拥有一台能够响应请求的服务器，那么可以使用<code>&lt;BrowserRouter&gt;</code>；如果使用静态文件服务器，则可以选用<code>&lt;HashRouter&gt;</code>。</p>
<h3 id="route-matching">Route Matching</h3>
<p>路由匹配组件主要包含<code>&lt;Route&gt;</code>和<code>&lt;Switch&gt;</code>这两个组件。</p>
<h4 id="route"><code>&lt;Route&gt;</code></h4>
<p>路由的匹配是通过<code>&lt;Route&gt;</code>组件的<code>path</code> prop 与当前位置路径的比较来完成的，如果比较成功则渲染组件内容，如果失败则渲染为空。没有<code>path</code> prop 的<code>&lt;Route&gt;</code>总是会得到匹配。</p>
<p>开发人员可以在任意需要渲染内容的位置包含<code>&lt;Route&gt;</code>，通常情况需要通过<code>&lt;Switch&gt;</code>组件将一组路由放置到一起。</p>
<h4 id="switch"><code>&lt;Switch&gt;</code></h4>
<p><code>&lt;Switch&gt;</code>并非仅用来组织多个<code>&lt;Route&gt;</code>的，其拥有更多的潜在用途。比如<code>&lt;Switch&gt;</code>会迭代其全部子<code>&lt;Route&gt;</code>元素，并且只渲染匹配当前地置的第一个组件，这在具有多个同名路由、路由之间的动画过渡、没有路由匹配当前地址等场景下非常有用。</p>
<h3 id="route-rendering-props">Route Rendering Props</h3>
<p>开发人员可以通过<code>component</code>、<code>render</code>、<code>children</code>三个 props 选项，指定<code>&lt;Route&gt;</code>如何渲染一个组件。其中<code>component</code>和<code>render</code>较为常用。</p>
<ul>
<li><p><code>component</code>用于指定一个已经存在的 React 组件（<em><code>React.Component</code>组件或无状态的函数式组件</em>）。</p></li>
<li><p><code>render</code>接收一个内联函数，仅用于需要传递当前作用域内变量到组件的场景（因为不能在函数式组件当前使用当前作用域内的变量）。</p></li>
</ul>
<blockquote>
<p>不能在一个传递了作用域内变量的内联函数当中使用<code>component</code>，因为将会发生不必要的组件卸载和重复挂载。</p>
</blockquote>
<h3 id="navigation">Navigation</h3>
<p>React Router 提供<code>&lt;Link&gt;</code>组件用于在 Web 应用中建立链接，无论在哪里渲染<code>&lt;Link&gt;</code>组件，都会在 HTML 中生成一个<code>&lt;a&gt;</code>标签。其中<code>&lt;NavLink&gt;</code>是一种特殊的<code>&lt;Link&gt;</code>，访问路径匹配时可以为自身添加<code>active</code>等状态。必要的情况下，也可以通过<code>&lt;Redirect&gt;</code>强制使用其<code>prop</code>进行导航。</p>
<h2 id="代码分割">代码分割</h2>
<p>React 通过<code>webpack</code>、<code>babel-plugin-syntax-dynamic-import</code>、<code>react-loadable</code>完成代码分割。<code>webpack</code>已经内建了动态引入支持，如果你正在使用 Babel（<em>用来将 JSX 转换为 JavaScript</em>），那么可以使用<code>babel-plugin-syntax-dynamic-import</code>插件。该插件只是简单的允许 Babel 去解析动态引入，让 Webpack 能够方便的以代码分割的方式进行打包。因此，你的<code>.babelrc</code>可能是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [</span><br><span class="line">    <span class="string">"react"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"plugins"</span>: [</span><br><span class="line">    <span class="string">"syntax-dynamic-import"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>react-loadable</code>是一个用来进行动态加载的高优先级组件，它能自动处理各种边界状况，让代码分割工作变得简单，下面是一个简单的例子：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Loadable <span class="keyword">from</span> <span class="string">"react-loadable"</span>;</span><br><span class="line"><span class="keyword">import</span> Loading <span class="keyword">from</span> <span class="string">"./Loading"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LoadableComponent = Loadable(&#123;</span><br><span class="line">  loader: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">"./Dashboard"</span>),</span><br><span class="line">  loading: Loading</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadableDashboard</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">LoadableComponent</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>loader</code>选项是一个用来加载确切组件的函数，<code>loading</code>是一个处于加载状态真实组件的占位符组件。</p>
<h1 id="构建产品化的-react-应用">构建产品化的 React 应用</h1>
<p>生产环境下，React需要结合大量的第三方包协助开发，如何基于这些第三方包来组织一个合理的项目结构，对于新接触React的开发开发人员是一个需要逐步摸索的过程。这里笔者结合自己的实践经验，分享了组织React产品化项目的一些心得，并以此作为全文的收尾章节。</p>
<h2 id="项目结构">项目结构</h2>
<p>整体的项目构建上，笔者选用了<code>Webpack + Gulp</code>的工具栈，并没有采用create-react-app所使用的<code>npm script + webpack-plugin</code>方式，这样做的目的一方面是照顾开发团队的使用习惯，另一方面是让Webpack完成转译和代码打包的工作，而将自动化任务分离出来交给Gulp完成。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">├── config</span><br><span class="line">│   ├── base.js</span><br><span class="line">│   ├── common.js</span><br><span class="line">│   ├── develop.js</span><br><span class="line">│   ├── product.js</span><br><span class="line">│   └── style.js</span><br><span class="line">├── gulpfile.js</span><br><span class="line">├── package.json</span><br><span class="line">├── README.md</span><br><span class="line">├── server</span><br><span class="line">│   ├── app.js</span><br><span class="line">│   ├── common</span><br><span class="line">│   ├── dashboard</span><br><span class="line">│   └── login</span><br><span class="line">└── sources</span><br><span class="line">    ├── app.js</span><br><span class="line">    ├── assets</span><br><span class="line">    ├── common</span><br><span class="line">    ├── dashboard</span><br><span class="line">    ├── index.html</span><br><span class="line">    ├── layout</span><br><span class="line">    ├── login</span><br><span class="line">    ├── router.js</span><br><span class="line">    └── store.js</span><br></pre></td></tr></table></figure>
<p><code>config</code>目录是Webpack相关的配置，<code>server</code>目录是Express构建的用于组装模拟数据的Web服务端代码，<code>sources</code>目录则是React前端项目相关的代码。</p>
<h2 id="程序入口点">程序入口点</h2>
<p>单页面应用程序通常会拥有一个全局唯一的入口点<code>app.js</code>，主要用于挂载视图DOM，以及配置路由、热加载、权限拦截、全局状态管理等。在笔者项目当中，前端路由选用了<code>React Router 4</code>，UI组织库指定为<code>ant.design</code>，CSS代码则使用<code>node-sass</code>预处理。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// library</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">"./router.js"</span>;</span><br><span class="line"><span class="keyword">import</span> Auth <span class="keyword">from</span> <span class="string">"./common/utils/auth.js"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; LocaleProvider &#125; <span class="keyword">from</span> <span class="string">"antd"</span>;</span><br><span class="line"><span class="keyword">import</span> CN <span class="keyword">from</span> <span class="string">"antd/lib/locale-provider/zh_CN"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"babel-polyfill"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">"mobx-react"</span>;</span><br><span class="line"><span class="keyword">import</span> Store <span class="keyword">from</span> <span class="string">"./store"</span>;</span><br><span class="line"><span class="keyword">import</span> DevTools <span class="keyword">from</span> <span class="string">"mobx-react-devtools"</span>;</span><br><span class="line"><span class="comment">// css</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"./common/styles/base.scss"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"./common/styles/reset.scss"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"./common/styles/awesome/css/fontawesome-all.min.css"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"animate.css/animate.min.css"</span>;</span><br><span class="line"><span class="comment">// theme</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"antd/dist/antd.less"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"./common/styles/theme.less"</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;LocaleProvider locale=&#123;CN&#125;&gt;</span><br><span class="line">    &lt;Provider GlobalStore=&#123;Store&#125;&gt;</span><br><span class="line">      &lt;Router&gt;</span><br><span class="line">        &lt;DevTools /&gt;</span><br><span class="line">      &lt;<span class="regexp">/Router&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Provider&gt;</span><br><span class="line">  &lt;<span class="regexp">/LocaleProvider&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById("app")</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">Auth.initializer();</span></span><br><span class="line"><span class="regexp">Auth.interceptor();</span></span><br></pre></td></tr></table></figure>
<h2 id="路由配置">路由配置</h2>
<p>笔者将前端路由的具体配置分离到了单独的<code>router.js</code>文件，并且通过<code>React Loadable</code>来实现基于组件的代码分割和懒加载，与此同时还配置了全局的页面加载动效。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; HashRouter, Route, Link, Switch &#125; <span class="keyword">from</span> <span class="string">"react-router-dom"</span>;</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> Loadable <span class="keyword">from</span> <span class="string">"react-loadable"</span>;</span><br><span class="line"><span class="keyword">import</span> Loading <span class="keyword">from</span> <span class="string">"./common/components/loading"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; hot &#125; <span class="keyword">from</span> <span class="string">"react-hot-loader"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Login = Loadable(&#123;</span><br><span class="line">  loader: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">"./login/index.jsx"</span>),</span><br><span class="line">  loading: Loading</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> hot(<span class="built_in">module</span>)(<span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;HashRouter&gt;</span><br><span class="line">    &lt;Switch&gt;</span><br><span class="line">      &lt;Route exact path=<span class="string">"/"</span> component=&#123;Login&#125; /&gt;</span><br><span class="line">      &lt;Route exact path=<span class="string">"/login"</span> component=&#123;Login&#125; /&gt;</span><br><span class="line">      &lt;Route</span><br><span class="line">        path=<span class="string">"/layout"</span></span><br><span class="line">        component=&#123;Loadable(&#123;</span><br><span class="line">          loader: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">"./layout/index.jsx"</span>),</span><br><span class="line">          loading: Loading</span><br><span class="line">        &#125;)&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>HashRouter&gt;</span><br><span class="line">));</span><br></pre></td></tr></table></figure>
<h2 id="权限认证">权限认证</h2>
<p>项目当中，权限认证相关的功能都会被封装到一个<code>auth.js</code>进行集中处理，包括权限信息的初始化、HTTP权限状态的拦截、路由权限的处理。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> Http <span class="keyword">from</span> <span class="string">"./http.js"</span>;</span><br><span class="line"><span class="keyword">import</span> Encrypt <span class="keyword">from</span> <span class="string">"./encrypt.js"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Route, Redirect &#125; <span class="keyword">from</span> <span class="string">"react-router-dom"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; storage &#125; <span class="keyword">from</span> <span class="string">"../utils/helper"</span>;</span><br><span class="line"><span class="keyword">import</span> queryString <span class="keyword">from</span> <span class="string">"querystringify"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">/**  Handle url search */</span></span><br><span class="line">  initializer() &#123;</span><br><span class="line">    <span class="keyword">const</span> searchInfo = queryString.parse(location.search).info;</span><br><span class="line">    <span class="keyword">if</span> (searchInfo) &#123;</span><br><span class="line">      <span class="keyword">const</span> query = <span class="built_in">JSON</span>.parse(Base64.decode(searchInfo));</span><br><span class="line">      storage.set(<span class="string">"token"</span>, query.token);</span><br><span class="line">      storage.set(<span class="string">"username"</span>, query.username);</span><br><span class="line">      storage.set(<span class="string">"permissions"</span>, query.permissions);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Http interceptor */</span></span><br><span class="line">  interceptor() &#123;</span><br><span class="line">    Http.fetch.interceptors.request.use(</span><br><span class="line">      <span class="function"><span class="keyword">function</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> token = Encrypt.token.get();</span><br><span class="line">        <span class="keyword">if</span> (token) config.headers.Authorization = token;</span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">    Http.fetch.interceptors.response.use(</span><br><span class="line">      <span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> head = response.data.head;</span><br><span class="line">        <span class="keyword">const</span> body = response.data.body;</span><br><span class="line">        <span class="keyword">if</span> (head &amp;&amp; <span class="keyword">typeof</span> head === <span class="string">"object"</span> &amp;&amp; head.hasOwnProperty(<span class="string">"status"</span>)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (head.status === <span class="string">"TIMEOUT"</span>) &#123;</span><br><span class="line">            <span class="built_in">window</span>.location.href = body.url;</span><br><span class="line">            storage.empty();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Check if current route is authed */</span></span><br><span class="line">  authRoute(&#123; <span class="attr">component</span>: Component, ...rest &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Route</span><br><span class="line">        &#123;...rest&#125;</span><br><span class="line">        render=&#123;props =&gt;</span><br><span class="line">          Encrypt.token.get() ? (</span><br><span class="line">            &lt;Component &#123;...props&#125; /&gt;</span><br><span class="line">          ) : (</span><br><span class="line">            &lt;Redirect</span><br><span class="line">              to=&#123;&#123;</span><br><span class="line">                pathname: Http.url.login,</span><br><span class="line">                state: &#123; <span class="attr">from</span>: props.location &#125;</span><br><span class="line">              &#125;&#125;</span><br><span class="line">            /&gt;</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="整合mobx">整合Mobx</h2>
<p>状态管理框架方面，笔者选用了轻量好用的<code>Mobx</code>方案，并且通过建立全局<code>store</code>并将其分离至单独的<code>store.js</code>文件便于管理和维护，下面代码仅将全局全局过渡动画的状态位纳入<code>Mobx</code>管理。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; observable, computed, action &#125; <span class="keyword">from</span> <span class="string">"mobx"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Tag &#125; <span class="keyword">from</span> <span class="string">"antd"</span>;</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> Loading <span class="keyword">from</span> <span class="string">"./common/components/loading"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">  <span class="comment">/** 全局过渡动画 */</span></span><br><span class="line">  @observable</span><br><span class="line">  loading = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Store();</span><br></pre></td></tr></table></figure>
<p>由于在<code>app.js</code>当中已经完成了<code>mobx-react</code>所提供的<code>Provider</code>配置，因此子组件仅需注入该<strong>Store</strong>即可通过<code>this.props.GlobalStore</code>访问上面定义的全局动画状态位。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"./style.scss"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Link &#125; <span class="keyword">from</span> <span class="string">"react-router-dom"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; observer, inject &#125; <span class="keyword">from</span> <span class="string">"mobx-react"</span>;</span><br><span class="line"></span><br><span class="line">@inject(<span class="string">"GlobalStore"</span>)</span><br><span class="line">@observer</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalLayout</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;h1&gt;&#123;<span class="keyword">this</span>.props.GlobalStore.loading&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>完整的脚手架项目，请参见笔者Github当中提供的开源脚手架项目<strong><a href="https://github.com/uinika/rhino.git" target="_blank" rel="noopener">Rhino</a></strong>。</p>
</blockquote>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Hank
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://uinika.github.io/Web/React.html" title="React 16.6.x 全新全译">https://uinika.github.io/Web/React.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/JavaScript/" rel="tag"><i class="fa fa-tag"></i> JavaScript</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/Web/Http.html" rel="prev" title="HTTP 协议深入解析">
      <i class="fa fa-chevron-left"></i> HTTP 协议深入解析
    </a></div>
      <div class="post-nav-item">
    <a href="/Web/Python.html" rel="next" title="言简意赅 の Python3">
      言简意赅 の Python3 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#快速开始"><span class="nav-number">1.</span> <span class="nav-text">快速开始</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#jsx-语法"><span class="nav-number">2.</span> <span class="nav-text">JSX 语法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#向-jsx-中嵌入表达式"><span class="nav-number">2.1.</span> <span class="nav-text">向 JSX 中嵌入表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jsx-本身也是一种表达式"><span class="nav-number">2.2.</span> <span class="nav-text">JSX 本身也是一种表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指定-jsx-的属性"><span class="nav-number">2.3.</span> <span class="nav-text">指定 JSX 的属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用-jsx-指定子元素"><span class="nav-number">2.4.</span> <span class="nav-text">使用 JSX 指定子元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jsx-可以预防脚本注入攻击"><span class="nav-number">2.5.</span> <span class="nav-text">JSX 可以预防脚本注入攻击</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jsx-最终会被转换为对象"><span class="nav-number">2.6.</span> <span class="nav-text">JSX 最终会被转换为对象</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#元素-elements"><span class="nav-number">3.</span> <span class="nav-text">元素 Elements</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#渲染一个-react-元素到-dom"><span class="nav-number">3.1.</span> <span class="nav-text">渲染一个 React 元素到 DOM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#更新已经被渲染的-react-元素"><span class="nav-number">3.2.</span> <span class="nav-text">更新已经被渲染的 React 元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#react-元素是按需更新的"><span class="nav-number">3.3.</span> <span class="nav-text">React 元素是按需更新的</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#components-组件"><span class="nav-number">4.</span> <span class="nav-text">Components 组件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#函数式组件与类组件"><span class="nav-number">4.1.</span> <span class="nav-text">函数式组件与类组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#渲染一个组件"><span class="nav-number">4.2.</span> <span class="nav-text">渲染一个组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#组合使用多个组件"><span class="nav-number">4.3.</span> <span class="nav-text">组合使用多个组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#组件的抽取"><span class="nav-number">4.4.</span> <span class="nav-text">组件的抽取</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#props-是只读的"><span class="nav-number">4.5.</span> <span class="nav-text">Props 是只读的</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#state-状态"><span class="nav-number">5.</span> <span class="nav-text">State 状态</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#将函数式组件转换为类组件"><span class="nav-number">5.1.</span> <span class="nav-text">将函数式组件转换为类组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#向类组件添加-state"><span class="nav-number">5.2.</span> <span class="nav-text">向类组件添加 state</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#生命周期钩子"><span class="nav-number">6.</span> <span class="nav-text">生命周期钩子</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#componentdidmount钩子"><span class="nav-number">6.1.</span> <span class="nav-text">componentDidMount()钩子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#componentwillunmount钩子"><span class="nav-number">6.2.</span> <span class="nav-text">componentWillUnmount()钩子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#抽取-timer函数"><span class="nav-number">6.3.</span> <span class="nav-text">抽取 timer()函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#深入-state"><span class="nav-number">7.</span> <span class="nav-text">深入 State</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#单向数据流"><span class="nav-number">8.</span> <span class="nav-text">单向数据流</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#事件机制"><span class="nav-number">9.</span> <span class="nav-text">事件机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#绑定组件-this-到事件处理函数"><span class="nav-number">9.1.</span> <span class="nav-text">绑定组件 this 到事件处理函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#向事件处理函数传递参数"><span class="nav-number">9.2.</span> <span class="nav-text">向事件处理函数传递参数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#条件渲染"><span class="nav-number">10.</span> <span class="nav-text">条件渲染</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#元素变量"><span class="nav-number">10.1.</span> <span class="nav-text">元素变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内联条件渲染-运算符"><span class="nav-number">10.2.</span> <span class="nav-text">内联条件渲染-&amp;&amp;运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内联条件渲染-三目运算符"><span class="nav-number">10.3.</span> <span class="nav-text">内联条件渲染-三目运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#阻止组件的渲染"><span class="nav-number">10.4.</span> <span class="nav-text">阻止组件的渲染</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#list-和-key"><span class="nav-number">11.</span> <span class="nav-text">List 和 Key</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#列表组件"><span class="nav-number">11.1.</span> <span class="nav-text">列表组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#列表循环的-key"><span class="nav-number">11.2.</span> <span class="nav-text">列表循环的 key</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#key-的使用位置"><span class="nav-number">11.3.</span> <span class="nav-text">key 的使用位置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#key-必须唯一"><span class="nav-number">11.4.</span> <span class="nav-text">key 必须唯一</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#嵌入-map至-jsx"><span class="nav-number">11.5.</span> <span class="nav-text">嵌入 map()至 JSX</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#react-表单"><span class="nav-number">12.</span> <span class="nav-text">React 表单</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#受控组件"><span class="nav-number">12.1.</span> <span class="nav-text">受控组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#textarea-标签"><span class="nav-number">12.2.</span> <span class="nav-text">textarea 标签</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#select-标签"><span class="nav-number">12.3.</span> <span class="nav-text">select 标签</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作多个输入域"><span class="nav-number">12.4.</span> <span class="nav-text">操作多个输入域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设置属性值为-null"><span class="nav-number">12.5.</span> <span class="nav-text">设置属性值为 null</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#非受控组件"><span class="nav-number">12.6.</span> <span class="nav-text">非受控组件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#状态提升"><span class="nav-number">13.</span> <span class="nav-text">状态提升</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#添加第-2-个输入域"><span class="nav-number">13.1.</span> <span class="nav-text">添加第 2 个输入域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编写转换函数"><span class="nav-number">13.2.</span> <span class="nav-text">编写转换函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#完整-demo"><span class="nav-number">13.3.</span> <span class="nav-text">完整 Demo</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#组合与继承"><span class="nav-number">14.</span> <span class="nav-text">组合与继承</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#内容包含"><span class="nav-number">14.1.</span> <span class="nav-text">内容包含</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#特殊化"><span class="nav-number">14.2.</span> <span class="nav-text">特殊化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#react-编程思想"><span class="nav-number">15.</span> <span class="nav-text">React 编程思想</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#组件嵌套结构"><span class="nav-number">15.1.</span> <span class="nav-text">组件嵌套结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#组件功能说明"><span class="nav-number">15.2.</span> <span class="nav-text">组件功能说明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#完整示例代码"><span class="nav-number">15.3.</span> <span class="nav-text">完整示例代码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#深入-jsx"><span class="nav-number">16.</span> <span class="nav-text">深入 JSX</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#指定-react-的元素类型"><span class="nav-number">16.1.</span> <span class="nav-text">指定 React 的元素类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jsx-中的-props"><span class="nav-number">16.2.</span> <span class="nav-text">JSX 中的 props</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#以-javascript-表达式的方式"><span class="nav-number">16.2.1.</span> <span class="nav-text">以 JavaScript 表达式的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串字面量"><span class="nav-number">16.2.2.</span> <span class="nav-text">字符串字面量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#props-默认为-true"><span class="nav-number">16.2.3.</span> <span class="nav-text">props 默认为 true</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#props-对象扩展运算"><span class="nav-number">16.2.4.</span> <span class="nav-text">props 对象扩展运算</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jsx-的-children"><span class="nav-number">16.3.</span> <span class="nav-text">JSX 的 children</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串字面量-1"><span class="nav-number">16.3.1.</span> <span class="nav-text">字符串字面量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#嵌套的-jsx"><span class="nav-number">16.3.2.</span> <span class="nav-text">嵌套的 JSX</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#javascript-表达式作为子元素"><span class="nav-number">16.3.3.</span> <span class="nav-text">JavaScript 表达式作为子元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数作为子元素"><span class="nav-number">16.3.4.</span> <span class="nav-text">函数作为子元素</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#booleannullundefined-会被忽略"><span class="nav-number">16.4.</span> <span class="nav-text">boolean、null、undefined 会被忽略</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#proptypes-类型检查"><span class="nav-number">17.</span> <span class="nav-text">PropTypes 类型检查</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#proptypes"><span class="nav-number">17.1.</span> <span class="nav-text">PropTypes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#需要单一的子元素"><span class="nav-number">17.2.</span> <span class="nav-text">需要单一的子元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#默认的-props-值"><span class="nav-number">17.3.</span> <span class="nav-text">默认的 props 值</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#refs-和-dom"><span class="nav-number">18.</span> <span class="nav-text">Refs 和 DOM</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#添加关于-dom-元素的-ref-属性"><span class="nav-number">18.1.</span> <span class="nav-text">添加关于 DOM 元素的 ref 属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#将-ref-属性引用到当前类组件"><span class="nav-number">18.2.</span> <span class="nav-text">将 ref 属性引用到当前类组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ref-与函数式组件"><span class="nav-number">18.3.</span> <span class="nav-text">ref 与函数式组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#暴露子组件的-dom-引用到父组件"><span class="nav-number">18.4.</span> <span class="nav-text">暴露子组件的 DOM 引用到父组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#遗留-api字符串类型的-ref-属性"><span class="nav-number">18.5.</span> <span class="nav-text">遗留 API：字符串类型的 ref 属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#附加说明"><span class="nav-number">18.6.</span> <span class="nav-text">附加说明</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#非受控组件-1"><span class="nav-number">19.</span> <span class="nav-text">非受控组件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#默认值"><span class="nav-number">19.1.</span> <span class="nav-text">默认值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件上传"><span class="nav-number">19.2.</span> <span class="nav-text">文件上传</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#fragments-片断"><span class="nav-number">20.</span> <span class="nav-text">Fragments 片断</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#动机"><span class="nav-number">20.1.</span> <span class="nav-text">动机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用法"><span class="nav-number">20.2.</span> <span class="nav-text">用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#快捷语法"><span class="nav-number">20.3.</span> <span class="nav-text">快捷语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#带-key-属性的-fragment"><span class="nav-number">20.4.</span> <span class="nav-text">带 key 属性的 fragment</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#portals-传送门"><span class="nav-number">21.</span> <span class="nav-text">Portals 传送门</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#用法-1"><span class="nav-number">21.1.</span> <span class="nav-text">用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件冒泡"><span class="nav-number">21.2.</span> <span class="nav-text">事件冒泡</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#web-components"><span class="nav-number">22.</span> <span class="nav-text">Web Components</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#在-react-中使用-web-components"><span class="nav-number">22.1.</span> <span class="nav-text">在 React 中使用 Web Components</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在-web-components-中使用-react"><span class="nav-number">22.2.</span> <span class="nav-text">在 Web Components 中使用 React</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#错误边界"><span class="nav-number">23.</span> <span class="nav-text">错误边界</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#componentdidcatcherror-info的参数"><span class="nav-number">23.1.</span> <span class="nav-text">componentDidCatch(error, info)的参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#错误边界放置位置"><span class="nav-number">23.2.</span> <span class="nav-text">错误边界放置位置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#错误捕获的新行为"><span class="nav-number">23.3.</span> <span class="nav-text">错误捕获的新行为</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#组件堆栈记录"><span class="nav-number">23.4.</span> <span class="nav-text">组件堆栈记录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用-trycatch"><span class="nav-number">23.5.</span> <span class="nav-text">使用 try&#x2F;catch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用事件处理器"><span class="nav-number">23.6.</span> <span class="nav-text">使用事件处理器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#reconciliation-调和"><span class="nav-number">24.</span> <span class="nav-text">Reconciliation 调和</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#diffing-算法"><span class="nav-number">24.1.</span> <span class="nav-text">Diffing 算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#不同类型的元素"><span class="nav-number">24.1.1.</span> <span class="nav-text">不同类型的元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#相同类型的-dom-元素"><span class="nav-number">24.1.2.</span> <span class="nav-text">相同类型的 DOM 元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#相同类型的-react-组件元素"><span class="nav-number">24.1.3.</span> <span class="nav-text">相同类型的 React 组件元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#递归处理子元素"><span class="nav-number">24.1.4.</span> <span class="nav-text">递归处理子元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#keys"><span class="nav-number">24.1.5.</span> <span class="nav-text">Keys</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#权衡"><span class="nav-number">24.2.</span> <span class="nav-text">权衡</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#context-组件树上下文"><span class="nav-number">25.</span> <span class="nav-text">Context 组件树上下文</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#react.createcontext"><span class="nav-number">25.1.</span> <span class="nav-text">React.createContext</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#provider"><span class="nav-number">25.2.</span> <span class="nav-text">Provider</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#consumer"><span class="nav-number">25.3.</span> <span class="nav-text">Consumer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一个完整的例子"><span class="nav-number">25.4.</span> <span class="nav-text">一个完整的例子</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#accessibility-可访问性"><span class="nav-number">26.</span> <span class="nav-text">Accessibility 可访问性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#语义化-html"><span class="nav-number">26.1.</span> <span class="nav-text">语义化 HTML</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可访问表单的label"><span class="nav-number">26.2.</span> <span class="nav-text">可访问表单的&lt;label&gt;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#输入焦点管理"><span class="nav-number">26.3.</span> <span class="nav-text">输入焦点管理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#代码切割"><span class="nav-number">27.</span> <span class="nav-text">代码切割</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#import"><span class="nav-number">27.1.</span> <span class="nav-text">import()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#react-loadable"><span class="nav-number">27.2.</span> <span class="nav-text">react-loadable</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于路由进行切割"><span class="nav-number">27.3.</span> <span class="nav-text">基于路由进行切割</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#整合-jquery"><span class="nav-number">28.</span> <span class="nav-text">整合 jQuery</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#高阶组件"><span class="nav-number">29.</span> <span class="nav-text">高阶组件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#render-props"><span class="nav-number">30.</span> <span class="nav-text">Render Props</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#严格模式与性能优化"><span class="nav-number">31.</span> <span class="nav-text">严格模式与性能优化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#react-router-4"><span class="nav-number">32.</span> <span class="nav-text">React Router 4</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本组件"><span class="nav-number">32.1.</span> <span class="nav-text">基本组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#routers"><span class="nav-number">32.1.1.</span> <span class="nav-text">Routers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#route-matching"><span class="nav-number">32.1.2.</span> <span class="nav-text">Route Matching</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#route"><span class="nav-number">32.1.2.1.</span> <span class="nav-text">&lt;Route&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#switch"><span class="nav-number">32.1.2.2.</span> <span class="nav-text">&lt;Switch&gt;</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#route-rendering-props"><span class="nav-number">32.1.3.</span> <span class="nav-text">Route Rendering Props</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#navigation"><span class="nav-number">32.1.4.</span> <span class="nav-text">Navigation</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代码分割"><span class="nav-number">32.2.</span> <span class="nav-text">代码分割</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#构建产品化的-react-应用"><span class="nav-number">33.</span> <span class="nav-text">构建产品化的 React 应用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#项目结构"><span class="nav-number">33.1.</span> <span class="nav-text">项目结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#程序入口点"><span class="nav-number">33.2.</span> <span class="nav-text">程序入口点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#路由配置"><span class="nav-number">33.3.</span> <span class="nav-text">路由配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#权限认证"><span class="nav-number">33.4.</span> <span class="nav-text">权限认证</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#整合mobx"><span class="nav-number">33.5.</span> <span class="nav-text">整合Mobx</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Hank"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Hank</p>
  <div class="site-description" itemprop="description">My world of IT, learn it & play it.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">53</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/uinika" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;uinika" rel="noopener" target="_blank"><i class="fa fa-fw fa-github-alt"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/uinika/posts" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;uinika&#x2F;posts" rel="noopener" target="_blank"><i class="fa fa-fw fa-quora"></i>知乎</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:uinika@outlook.com" title="Email → mailto:uinika@outlook.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>Email</a>
      </span>
      <span class="links-of-author-item">
        <a href="skype:uinika@outlook.com?call|chat" title="Skype → skype:uinika@outlook.com?call|chat" rel="noopener" target="_blank"><i class="fa fa-fw fa-skype"></i>Skype</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/7998979/uinika?tab=profile" title="Stack Overflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;7998979&#x2F;uinika?tab&#x3D;profile" rel="noopener" target="_blank"><i class="fa fa-fw fa-stack-overflow"></i>Stack Overflow</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2010 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"><a rel="license noopener" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a></span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">1.5m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">23:25</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
